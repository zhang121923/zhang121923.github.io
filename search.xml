<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6中一个神奇的WeakMap]]></title>
    <url>%2F2017%2F08%2F24%2FES6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%A5%87%E7%9A%84WeakMap%2F</url>
    <content type="text"><![CDATA[​ 这两天在项目中使用ES6中的Map数据结构时，接触到了一个新的类似Map结构的数据类型：WeakMap。它的用法与Map相仿，只是区别也很大，下面稍微整理了一下。一、基本用法​ 同Map一样，两者对比如下：属性和方法MapWeakMap生成新对象new Map()new WeakMap()设置键值对set(key,value)set(key,value)获取键get(key)get(key)是否存在has(key)has(key)删除键delete(key)delete(key)清空所有键clear()无clear方法成员大小size无size属性​ 为什么没有size属性和clear方法？区别里面说！二、由来和区别2.1 结构的唯一区别​ weakMap和Map的结构相似，但是唯一的区别就在于：weakMap只接收对象作为键名(除null)，不能使用原始类型作为键名。2.2 由来​ 为什么已经有了Map，还要设计一个WeakMap？它的设计目的在于，键名是对象的弱引用，1234var wMap = new WeakMap();wMap.set(1,'hello'); //TypeError: Invalid value used as weak map keywMap.set(Symbol(),'hello'); //TypeError: Invalid value used as weak map key//说明基本类型、Symbol类型都不可作为键名而弱引用是不计入垃圾回收机制的，所以其所对应的对象可能就会被自动回收。一旦对象被回收，WeakMap就会自动移除对应键值对。​ 比如我们使用一个DOM元素作为WeakMap结构，当某个DOM元素被移除，其对应的WeakMap记录就会被自动移除。​ 一般来说WeakMap的专用场合就是：它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄露。​ 来看看这个例子：1234567891011&lt;div id="root"&gt; &lt;P&gt;1&lt;/P&gt;&lt;/div&gt;&lt;script&gt; var wMap = new WeakMap(); var ele = document.getElementsByTagName('p')[0]; wMap.set(ele,'hello'); document.getElementById('root').removeChild(ele); ele = null; console.log('获取的值是：', wMap.get(ele)); //获取的值是： undefined&lt;/script&gt;​ 可以看到，当我们删除p元素后，其ele所对应的键也自动消失了，再次引用该键名就只能返回undefined。​ 就是因为键名不被计入这个特性，所以WeakMap就没有size属性和clear方法，同样也就不具备遍历操作(key()、values()、entries()，以及forEach等方法)。123456789var wMap = new WeakMap(); var ele = document.querySelector('p'); var a = &#123;'a':1&#125;; wMap.set(ele,'hello'); wMap.set(a,'hello'); //wMap.clear(); //TypeError: wMap.clear is not a function //wMap.forEach(function(value,key,wMap)&#123;//TypeError: wMap.forEach is not a function //console.log(key+':'+value) //&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中混淆到我的几个“包含”]]></title>
    <url>%2F2017%2F08%2F23%2FJS%E4%B8%AD%E6%B7%B7%E6%B7%86%E5%88%B0%E6%88%91%E7%9A%84%E5%87%A0%E4%B8%AA%E2%80%9C%E5%8C%85%E5%90%AB%E2%80%9D%2F</url>
    <content type="text"><![CDATA[​ 记性这么差的我并且之前一直坚信这几个“包含”应该是简单、易记的，但是后来发现还是自己犯了人生三大错觉。所以吸取教训，这一次彻底的整理一次Javascript中我们所遇到的包含。整理时主要遇到的就下面你看到的这些，如果文中有没有提到的、你还知道的“包含”，还请提示我一下！​ 好了，闲不说，下面开始！1、indexOf：最基础的“包含”​ 该方法可用于数组和字符串。ArrayString函数Array.prototype.indexOf(element[,fromIndex])String.prototype.indexOf(searchStr[,fromIndex])参数element：元素 fromIndex：起始索引searchStr：检索的字符串 fromIndex：起始索引返回值找到的第一个元素的下标，无则为-1指定值的第一次出现的索引，无则返回-1fromIndex大于或等于数组长度，返回值为-1；为负值表示从数组尾部（-1开始）开始查找大于或等于，同数组返回-1，除非searchStr为空字符串则返回字符串总长度；为负时则查找整个字符串大小写X区分大小写​ 兼容性：ChromefireFoxIEOperasafari字符串YYYYY数组Y1.59YY更多细节请参考：数组 字符串2、in关键字​ in的字面意思是‘在xxx中’、‘属于’等名词，所以这自然而然和”包含“有关系。在JS中，经常能看到in关键字，例如for...in语句中的还是接下来我们会涉及的”包含“意义的。​ 我们还是从数组和对象两这来分辨in的用法：2.1、对象​ 在对象中，in代表在某个对象中是否包含某个属性，有则返回true，无则返回false。来看个例子：123456var obj = &#123;'a' : 1 , 'b' : 2&#125;;obj.__proto__.c = 3; //ES6'a' in obj; //true1 in obj; //false'c' in obj; //true'toString' in obj //true​ 从此得出：in表示某属性名是否属于某对象，包含对象原型链上的属性。其实这一点在for...in语句上也体现了出来，它会将对象的全部属性包含原型链上的所有属性全部遍历一遍。​ 兼容性：ChromeFireFoxIEOperaSafariYYYYY2.2、数组​ 数组的in与之类似，不过它查找的是数组索引是否有元素。看个例子：123456var arry = [1,2,3,4];1 in arry; //true0 in arry; //true4 in arry; //false,数组最大下标为3，所以下标越界，返回false'length' in arry; //trueSymbol.iterator in arry; //true ES6​ 与对象类似，它不仅会查找数组本身下标元素，还会查找对象原型上的所有属性。​ 兼容性同上。更多细节，请查看：in关键字3、contains：字面意思真的是包含哈​ 就是因为其字面意思，我一度时间以为不论数组、字符串、对象都有该方法，但是。。。呵呵，还是怪自己。。。​ 在此说明：对象和数组没有contains方法，对象和数组没有contains方法，对象和数组没有contains方法（敲三遍）。​ However，DOM对象却具备这个方法：3.1、node.contains(otherNode)​ 含义：node节点中是否包含otherNode节点，是则返回true，否则返回false。来看这个例子：1234567891011&lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="silbing"&gt;&lt;/div&gt;&lt;script&gt; var p = document.getElementById('parent'); var c = document.getElementById('child'); var s = document.getElementById('silbing'); console.log(p.contains(c)); //true console.log(p.contains(s)); //false&lt;/script&gt;​ 兼容性：ChromeFireFoxIEOperaSafariY9.05.0YY* 3.2、node.compareDocumentPosition(otherNode)​ 谈到节点的关系，那就得提到这个方法了。确实很陌生，没怎么见过，但是人家可以有W3C正规血统，只是名字这…么…长…，在加上它的返回值最开始返回的是比特码，所以才这么不出名，但是要论真正的”定位“，那该方法确实比contains强太多了。​ 直接上代码，先看看：12345678910&lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="silbing"&gt;&lt;/div&gt;&lt;script&gt; var p = document.getElementById('parent'); var c = document.getElementById('child'); var s = document.getElementById('silbing'); alert(p.compareDocumentPosition(c)) //打出：20&lt;/script&gt;​ 纳闷了，为啥是20？？？这就是之前说的，它的返回值是比特码值的组合，具体全部看下表：​ 方法：node.compareDocumentPosition(otherNode)比特码十进制含义00011不再同一文档中00102node在otherNode之后01004node在otherNode之前10008otherNode包含node1000016node包含otherNode10000032待定​ 现在知道为什么是20了吧？20 = 16 + 4；表示parent元素包含child元素，并且在child之前出现。​ 兼容性：（毕竟是正规血统，兼容性很好，只是这万恶的IE……）ChromeFireFoxIEOperaSafariYY9.0YY4、includes​ 这个”包含“和最开始介绍的in有点像，不同的是它是数组中值、字符串中子串的检索。4.1、数组​ Array.prototype.includes(ele[,fromIndex])，表示ele元素是否包含在数组中，可选参数表示开始检索的下标。看看下面代码：1234[1,2,3].includes(2); //true[1,2,3,NaN].includes(NaN); //true[1,2,3].includes(3,3); //false[1,2,3].includes(2,-1); //true​ 从测试代码可以看出：可以检索数组中某个值是否存在可以检索数组中是否存在NaNfromIndex如果大于等于数组长度，直接返回false，不予检索fromIndex如果小于0，表示整个数组将会被检索​兼容性：ChromeFireFoxIEEdgeOperaSafari4743N143494.2、字符串​ str.includes(searchStr[,position])，用于判断一个字符串是否包含在另一个字符串中，是返回true，否则返回false。​ 该方法与indexOf类似，严格区分大小写。​ 兼容性：ChromeFireFoxIEOperaSafari4140NN9​ 冷知识：在FireFox 19~39中，该方法叫contains()，但是因为一个神奇的BUG冲突，所以才修改为includes。故事详情请查看：详情以上就是容易让我混淆的一系列”包含“，当然，肯定还有其他方法，例如hasOwnProperty()方法，但是这种方法意义就比较明显了。如有问题，忘各位指正。夜深了，洗洗睡了！！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular指令中细节描述]]></title>
    <url>%2F2017%2F08%2F22%2F%E9%92%88%E5%AF%B9angular%E6%8C%87%E4%BB%A4%E4%B8%AD%E5%87%A0%E4%B8%AA%E7%BB%86%E8%8A%82%E9%98%90%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一、先谈angular加载​ 在描述指令内部区别之前，咱们先说说angular在加载时都做了什么：页面加载时，当加载完angularJS所在的&lt;script&gt;后，angular就开始启动了，它会先创建一系列的工具、加载模块等（例如bindJquery()）。在上一步的基础上，它会监听DOMContentLoader事件123jqlite(function()&#123; angularInit(widow.document,bootstrap);&#125;);当发现DOM已加载完成时，angular将初始化启动整个angular项目，它重新遍历所有DOM，大致源代码如下12345678910111213function angularInit(element,bootstrap)&#123; var appElement, //定义ng-app根节点所在元素 model, //angular项目根名称，即ng-app的值 config=&#123;&#125;; //相关 forEach(ngAttrPrefixes, //ngAttrPrefixes=['ng-','data-ng-','ng:','x-ng-']; function(prefix)&#123; var name = prefix + 'app'; if(!appElement &amp;&amp; element.hasAttribute &amp;&amp; element.hasAttribute(name))&#123; appElement = element; model = element.getAttribute(name); &#125; &#125;); &#125;​这样就能找到angular项目根节点(ng-app)并启动它【注：若无该节点，angular希望我们手动启动，方法是angular.bootstrap()方法】。在第1步的加载模块中(并不是DOM加载完成后哦，分清楚)，angularJS会为angular对象赋予很多特性方法123456789function publishExternalAPI(angular)&#123; extend(angular,&#123; 'bootstrap':bootstrap, 'bind':bind, 'element':jqLite, //等等一系列方法&#125;); angularModule = setupModuleLoader(window);//配置angular的接口方法&#125;并且，在该方法中，就会为angular模块加载指令123456789101112131415161718angularModule('ng',['ngLocale'],['$provide', //加载ng模块，该模块依赖于ngLocale模块 function ngModule($provide)&#123; $provide.provider(&#123; $$sanitizeUri: $$sanitizeUriProvider &#125;); $provide.provider('$compile',$compileProvider). directive(&#123; a: htmlAnchorDirective, ngBind: ngBindDirective, //又是一系列自带的指令 &#125;). directive(&#123; ngInclude:ngIncludeFillContentDirective &#125;). directive(ngAttributeAliasDirective). directive(ngEventDirective);//终于完了 &#125;]);上面的代码一大堆，重点就在这个directive()方法了。12345678910111213141516171819202122232425262728293031function $compileProvider($provide,$$sanitizeUriProvider)&#123; //省略一堆代码，直接看directive方法 this.directive = function registerDirective(name,directiveFactory)&#123; //验证信息，省 $provide.factory(name+suffix,['$injector','$exceptionHandler'],//suffix:Directive function($injector,$exceptionHandler)&#123; var directives = []; forEach(hasDirective[name],function(directiveFactory, index)&#123; try &#123; var directive = $injector.invoke(directiveFactory); if(isFunction(directive))&#123; //记住这组if-else代码，之后会用到 directive = &#123;compile:valueFn(directive) &#125;; &#125;else if(!directive.compile &amp;&amp; directive.link)&#123; directive.compile = valueFn(directive.link); &#125; directive.priority = directive.priority || 0; //设置一系列指令属性，包括index、name、require、restrict、$$moduleName directives.push(directive); &#125;catch (e) &#123; $exceptionHandler(e); &#125; &#125;); return directives; &#125;]); &#125; hasDirective[name].push(directiveFactory); &#125; else&#123; forEach(name, reverseParams(registerDirective)); &#125; return this;&#125;;从代码可以看出来，angular为我们提供了大量的指令，并且也提供了自定义指令。二、自定义指令中细节描述​ 前面说了很多，主要就是想给现在这一块做一个铺垫，现在让我们来回归原始话题，自定义指令说那些容易混淆的细节。1、controller、compile、link的区别​ 我们知道，在自定义指令中，有这三个方法，看上去样子差不多，之前刚接触angular时真的分不清这三者关系。现在我们具体来看看。从执行顺序上：12345678910111213141516171819202122&lt;body ng-app="myApp" ng-controller="myCtrl"&gt;&lt;my-Directive&gt;&lt;/my-Directive&gt;&lt;script&gt; angular.module('myApp',[]) .directive('myDirective',function()&#123; return &#123; compile:function()&#123; console.log('compile'); &#125;, link:function () &#123; console.log('link'); &#125;, controller:function () &#123; console.log('controller'); &#125; &#125; &#125;) .controller('myCtrl',function($scope)&#123; &#125;);&lt;/script&gt;&lt;/body&gt;其在控制台输出是这样的：可以看到最先输出的时compile，controller之后输出，并未输出link。这个原因就在于之前源码里面的那一组让记住的if-else了：12345if(isFunction(directive))&#123; //记住这组if-else代码，之后会用到 directive = &#123;compile:valueFn(directive) &#125;;&#125;else if(!directive.compile &amp;&amp; directive.link)&#123; directive.compile = valueFn(directive.link);&#125;这代码应该就是直接是说明这个原因的关键了吧。从内部结构上：我们知道，其实在从compile中，它返回了两个函数preLink与postLink，实际link函数就是postLink的演变，下面我会讲到链接函数的作用。​从官方回答中看：compile：指令加载编译时运行，此时对它来说，]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular爬坑日记]]></title>
    <url>%2F2017%2F08%2F21%2Fangular%E7%88%AC%E5%9D%91%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、angular实现原理略谈​ 虽然业界将angular规划为MVC模式，但是它更有MVVM影子，其双向绑定就实现了ViewModel。下面聊聊我对angular实现原理的理解：​ 1.1 浏览器加载HTML页面时，遇到外联&lt;script&gt;标签时会发出HTTP请求来下载该外部文件​ 1.2 angular.js如此被下载下来，并监听页面DomContentLoad事件​ 1.3 一旦DomContentLoad事件触发（即页面DOM加载完成）时，angular就开始执行​ 1.4 angular会在页面中寻找ng-app字样标签，一旦找到则开始angular启动初始化（如果没有找到，angualr期望我们手动启动应用，需要使用angular的bootstrap()方法，即：12var ele = document.createElement('div');Angular.bootstrap(ele,['myApp']);1Angular.bootstrap(document,['myApp']);注意：bootstrap()方法只能启动angular应用一次）。​ 1.5 angular会在找到ng-app后 将其值配置injector服务。一旦程序加载完成，injector服务会配置compile服务，该服务的作用是遍历页面找到所有的指令将它们的链接函数合并为一个单一的链接函数，并将链接函数编译好的模板托付给$rootScope。​ 1.6 $rootScope将在angular上下文中启动$digest脏循环并将其传播到子作用域中​ 1.7 $digest会等待$evalAsync队列清空和$watch不再变化，此时才将整个修改后的DOM交给浏览器开始重新渲染显示。二、对脏检查与$apply的细节描述​ 2.1 页面进行双向绑定时，scope作用域会自动为其增加watcher函数监听值的变化，并自动调用$scope.$apply()。​ 2.2 何时开始监听值的变化呢？这就是脏检查的产生原因。调用$scope.$digest()开始进入脏循环，会触发一系列watcher函数，一旦发生值的变化，就调用回调函数。​ 2.3 angular会在上下文作用域中自动调用$apply进入脏循环，我们也可以手动调用$scope.$digest进入脏检测，或者调用$scope.$apply()方法，后者实际调用$rootScope.$digest()。​ 2.4 何时需要手动调用进入脏检测呢？angular只负责将其上下文变更做出自动响应，但是如果我们在上下文之外（例如：JS代码修改、setTimeout等），就需要手动调用。三、代码爬坑3.1 ng-app启动Angular应用1var app = angular.module('myApp',[]);[ ]:方括号表示该模块是否需要依赖某些模块。无论有无依赖，这个数组参数必须存在。3.2 自定义指令细节​ 以代码为例：12345678910111213141516171819app.directive('myDirective',function($templateCache)&#123; return &#123; restrict:'EACM', //分别代表元素、属性、类名、注释 template:'', //可直接编写模板HTML代码，还可使用$templateCache.get('')获取外部文件 scope:&#123; XX:'=', //实现父子域双向绑定，直接将子域该内容绑定到父域 XX:'@', //将子域中&#123;&#123;&#125;&#125;中的值单向绑定到父域，父域改变是子域会改变，但反之不行 XX:'&amp;', //将子域XX函数处理以及返回值绑定到父域函数执行 &#125;, controller:function($scope,$element)&#123;&#125;, //注意三者参数名 link:function(scope,el,attr)&#123;&#125;, compile:function(tElement,tAttrs,transclude)&#123; //此处参数可省略 return &#123; pre:function(scope,iElement,iAttrs)&#123;&#125;, post:function(scope,iElement,iAttrs)&#123;&#125; &#125; &#125; &#125;&#125;);link、controller、compile三者关系controller先运行。如果link和compile都存在只运行compile（实际上link就是compile中的postLink函数）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
