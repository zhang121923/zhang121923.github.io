<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js-xlsx插件使用.md</title>
    <url>/2019/08/27/js-xlsx%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<!-- build time:Tue Apr 07 2020 20:01:07 GMT+0800 (GMT+08:00) --><p>​ 最近项目中某功能需要解析特定内容格式的<code>Excel</code>文件，会将解析的表格数据发送给后端服务器进行校验并持久化，这里为什么不直接上传文件给后端解析。是因为在前端会有一个预览数据的过程，直接读取文件后在前端界面会显示一个解析后的表格供用户预览，并且提供预览数据删除功能，所以将表格解析的活儿放到的前端处理。</p><h5 id="一、初识js-xlsx"><a href="#一、初识js-xlsx" class="headerlink" title="一、初识js-xlsx"></a>一、初识<code>js-xlsx</code></h5><p>​</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>uEditor单张图片上传问题解决</title>
    <url>/2019/06/05/uEditor%E5%8D%95%E5%BC%A0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<!-- build time:Tue Apr 07 2020 20:01:07 GMT+0800 (GMT+08:00) --><p>​ 最近做的一个项目是将之前的一个项目进行前后端分离后的一个拓展项目，刚好这个项目中就是用到了百度的富文本器插件，其中遇到了单张图片上传的问题。再次将解决办法做一个总结。</p><h4 id="一、前后端分离"><a href="#一、前后端分离" class="headerlink" title="一、前后端分离"></a>一、前后端分离</h4><p>​ 这个问题解决在网上处理办法已经有很多了，这里就不赘述了，其实最重要的还是配置<code>ueditor.config.js</code>中的<code>serverUrl</code>，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">serverUrl: <span class="string">"后端服务器地址XXX"</span></span><br></pre></td></tr></table></figure><p>​ 在此配置完成后，基本上已经不需要修改什么代码了。(此处需要注意的是后端是否配置跨域，因为跨域是为了解决我们之后图片上传时<code>ajax</code>请求的跨域处理)</p><p>二、单张上传处理</p><h5 id="I、原来单张上传原理"><a href="#I、原来单张上传原理" class="headerlink" title="I、原来单张上传原理"></a>I、原来单张上传原理</h5><p>​ 看过源码的小伙伴应该都了解单张图片上传的方式是什么。实际上它的步骤是这样的：</p><ul><li><p>新建一个<code>iframe</code>（实际上这个方法主要是为了兼容低版本浏览器）</p></li><li><p>在这个<code>iframe</code>种添加了一个包含<code>type=&quot;file&quot;</code>的<code>input</code>的表单<code>form</code></p></li><li><p>我们监听这个<code>iframe</code>的变化，实际就是有图片被选择上传后，它会去读取这个<code>iframe</code>中的数据使用表单的方式提交</p><p>流程就是这样，但存在的问题就有以下几点：</p></li></ul><p>1、前后端分离后，新建的这个<code>iframe</code>和当前的文档是跨域的，因此下面这段代码是获取不到值的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只是原版本的代码，源码在ueditor.all.js中的大概24545行</span></span><br><span class="line">body = (iframe.contentDocument || iframe.contentWindow.document).body</span><br></pre></td></tr></table></figure><p>​ 也就是说，这个<code>contentDocument</code>和<code>contentWindow</code>是无法获取的，程序直接报错被<code>catch</code>捕捉弹出异常。</p><p>2、这里使用了表单提交，如果，我是说如果，如果我们的<code>ueditor</code>插件本来就在一个表单中，那你这里再插入一个表单，那么这两个表单就乱套了，虽然这个表单是放在<code>iframe</code>中的，但是这不是有是上面这个问题了嘛。</p><h5 id="II、解决办法"><a href="#II、解决办法" class="headerlink" title="II、解决办法"></a>II、解决办法</h5><p>​ 说了这么多，是时候给出解决办法了。解决办法如下：</p><ul><li><p>不要<code>iframe</code></p></li><li><p>不要<code>form</code>表单提交</p><p>方法就是这么简单直接！！</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###### 思路：</span><br></pre></td></tr></table></figure><p>1、直接使用<code>input file</code> 标签，去掉原来的<code>iframe</code>和<code>form</code>，直接监听<code>input</code>的变化</p><p>2、不使用表单方式提交文件，而是采用<code>ajax</code>方式提交，你可以选择任何一种<code>ajax</code>提交数据，我这里使用原生的<code>XMLHttpRequest</code>进行提交，提交后清空<code>input</code>的值。</p><p>（到这里你应该清楚为什么前面说要在后端代码中配置跨域了吧）</p><p>好，说了这么多，直接上代码，修改后的代码都添加了注释以供理解。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">UE.plugin.register(<span class="string">'simpleupload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> me = <span class="keyword">this</span>,</span><br><span class="line">            containerBtn,</span><br><span class="line">            timestrap = (+<span class="keyword">new</span> <span class="built_in">Date</span>()).toString(<span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">initUploadBtn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> w = containerBtn.offsetWidth || <span class="number">20</span>,</span><br><span class="line">                h = containerBtn.offsetHeight || <span class="number">20</span>,</span><br><span class="line">                btnStyle = <span class="string">'display:block;width:'</span> + w + <span class="string">'px;height:'</span> + h + <span class="string">'px;overflow:hidden;border:0;margin:0;padding:0;position:absolute;top:0;left:0;filter:alpha(opacity=0);-moz-opacity:0;-khtml-opacity: 0;opacity: 0;cursor:pointer;'</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 直接使用input file标签，将原来的form标签去除，防止外层嵌套form对此造成影响</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">var</span> inputHtml = <span class="string">'&lt;input id="edui_input_'</span> + timestrap + <span class="string">'" type="file" accept="image/*" name="'</span> + me.options.imageFieldName + <span class="string">' "style="'</span> + btnStyle + <span class="string">'" /&gt;'</span>;</span><br><span class="line">            containerBtn.innerHTML = inputHtml;</span><br><span class="line">            <span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'edui_input_'</span> + timestrap);</span><br><span class="line"></span><br><span class="line">            input.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!input.value) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">var</span> loadingId = <span class="string">'loading_'</span> + (+<span class="keyword">new</span> <span class="built_in">Date</span>()).toString(<span class="number">36</span>);</span><br><span class="line">                <span class="keyword">var</span> imageActionUrl = me.getActionUrl(me.getOpt(<span class="string">'imageActionName'</span>));</span><br><span class="line">                <span class="keyword">var</span> params = utils.serializeParam(me.queryCommandValue(<span class="string">'serverparam'</span>)) || <span class="string">''</span>;</span><br><span class="line">                <span class="keyword">var</span> action = utils.formatUrl(imageActionUrl + (imageActionUrl.indexOf(<span class="string">'?'</span>) == <span class="number">-1</span> ? <span class="string">'?'</span> : <span class="string">'&amp;'</span>) + params);</span><br><span class="line">                <span class="keyword">var</span> allowFiles = me.getOpt(<span class="string">'imageAllowFiles'</span>);</span><br><span class="line">                <span class="comment">// 使用Form对象提交数据</span></span><br><span class="line">                <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">                formData.append(<span class="string">"upfile"</span>, input.files[<span class="number">0</span>]);</span><br><span class="line">                me.focus();</span><br><span class="line">                me.execCommand(<span class="string">'inserthtml'</span>, <span class="string">'&lt;img class="loadingclass" id="'</span> + loadingId + <span class="string">'" src="'</span> + me.options.themePath + me.options.theme + <span class="string">'/images/spacer.gif" title="'</span> + (me.getLang(<span class="string">'simpleupload.loading'</span>) || <span class="string">''</span>) + <span class="string">'" &gt;'</span>);</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">showErrorLoader</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (loadingId) &#123;</span><br><span class="line">                        <span class="keyword">var</span> loader = me.document.getElementById(loadingId);</span><br><span class="line">                        loader &amp;&amp; domUtils.remove(loader);</span><br><span class="line">                        me.fireEvent(<span class="string">'showmessage'</span>, &#123;</span><br><span class="line">                            <span class="string">'id'</span>: loadingId,</span><br><span class="line">                            <span class="string">'content'</span>: title,</span><br><span class="line">                            <span class="string">'type'</span>: <span class="string">'error'</span>,</span><br><span class="line">                            <span class="string">'timeout'</span>: <span class="number">4000</span></span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 判断后端配置是否没有加载成功 */</span></span><br><span class="line">                <span class="keyword">if</span> (!me.getOpt(<span class="string">'imageActionName'</span>)) &#123;</span><br><span class="line">                    showErrorLoader(me.getLang(<span class="string">'autoupload.errorLoadConfig'</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断文件格式是否错误</span></span><br><span class="line">                <span class="keyword">var</span> filename = input.value,</span><br><span class="line">                    fileext = filename ? filename.substr(filename.lastIndexOf(<span class="string">'.'</span>)) : <span class="string">''</span>;</span><br><span class="line">                <span class="keyword">if</span> (!fileext || (allowFiles &amp;&amp; (allowFiles.join(<span class="string">''</span>) + <span class="string">'.'</span>).indexOf(fileext.toLowerCase() + <span class="string">'.'</span>) == <span class="number">-1</span>)) &#123;</span><br><span class="line">                    showErrorLoader(me.getLang(<span class="string">'simpleupload.exceedTypeError'</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">                xhr.open(<span class="string">'post'</span>, action, <span class="literal">true</span>)</span><br><span class="line">                <span class="keyword">if</span> (me.options.headers &amp;&amp; <span class="built_in">Object</span>.prototype.toString.apply(me.options.headers) === <span class="string">"[object Object]"</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> me.options.headers) &#123;</span><br><span class="line">                        xhr.setRequestHeader(key, me.options.headers[key])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> res = <span class="built_in">JSON</span>.parse(xhr.responseText)</span><br><span class="line">                        <span class="keyword">var</span> link = me.options.imageUrlPrefix + res.url;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (res.state == <span class="string">'SUCCESS'</span> &amp;&amp; res.url) &#123;</span><br><span class="line">                            loader = me.document.getElementById(loadingId);</span><br><span class="line">                            loader.setAttribute(<span class="string">'src'</span>, link);</span><br><span class="line">                            loader.setAttribute(<span class="string">'_src'</span>, link);</span><br><span class="line">                            loader.setAttribute(<span class="string">'title'</span>, res.title || <span class="string">''</span>);</span><br><span class="line">                            loader.setAttribute(<span class="string">'alt'</span>, res.original || <span class="string">''</span>);</span><br><span class="line">                            loader.removeAttribute(<span class="string">'id'</span>);</span><br><span class="line">                            domUtils.removeClasses(loader, <span class="string">'loadingclass'</span>);</span><br><span class="line">                            me.fireEvent(<span class="string">"contentchange"</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            showErrorLoader(res.state);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        showErrorLoader(me.getLang(<span class="string">'simpleupload.loadError'</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    showErrorLoader(me.getLang(<span class="string">'simpleupload.loadError'</span>));</span><br><span class="line">                &#125;;</span><br><span class="line">                xhr.send(formData);</span><br><span class="line">                <span class="comment">// 将input的值抹掉</span></span><br><span class="line">                input.value = <span class="string">""</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            bindEvents: &#123;</span><br><span class="line">                <span class="string">'ready'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="comment">//设置loading的样式</span></span><br><span class="line">                    utils.cssRule(<span class="string">'loading'</span>,</span><br><span class="line">                        <span class="string">'.loadingclass&#123;display:inline-block;cursor:default;background: url(\''</span> +</span><br><span class="line">                        <span class="keyword">this</span>.options.themePath +</span><br><span class="line">                        <span class="keyword">this</span>.options.theme + <span class="string">'/images/loading.gif\') no-repeat center center transparent;border:1px solid #cccccc;margin-right:1px;height: 22px;width: 22px;&#125;\n'</span> +</span><br><span class="line">                        <span class="string">'.loaderrorclass&#123;display:inline-block;cursor:default;background: url(\''</span> +</span><br><span class="line">                        <span class="keyword">this</span>.options.themePath +</span><br><span class="line">                        <span class="keyword">this</span>.options.theme + <span class="string">'/images/loaderror.png\') no-repeat center center transparent;border:1px solid #cccccc;margin-right:1px;height: 22px;width: 22px;'</span> +</span><br><span class="line">                        <span class="string">'&#125;'</span>,</span><br><span class="line">                        <span class="keyword">this</span>.document);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">/* 初始化简单上传按钮 */</span></span><br><span class="line">                <span class="string">'simpleuploadbtnready'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">type, container</span>) </span>&#123;</span><br><span class="line">                    containerBtn = container;</span><br><span class="line">                    me.afterConfigReady(initUploadBtn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            outputRule: <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">                utils.each(root.getNodesByTagName(<span class="string">'img'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="regexp">/\b(loaderrorclass)|(bloaderrorclass)\b/</span>.test(n.getAttr(<span class="string">'class'</span>))) &#123;</span><br><span class="line">                        n.parentNode.removeChild(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular中修饰符的研究</title>
    <url>/2018/10/21/Angular%E4%B8%AD%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<!-- build time:Tue Apr 07 2020 20:01:07 GMT+0800 (GMT+08:00) --><h3 id="Angular中修饰符的研究"><a href="#Angular中修饰符的研究" class="headerlink" title="Angular中修饰符的研究"></a>Angular中修饰符的研究</h3><h4 id="一、先从TypeScript中说起"><a href="#一、先从TypeScript中说起" class="headerlink" title="一、先从TypeScript中说起"></a>一、先从TypeScript中说起</h4><p>​ 先来看一个例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">    move(distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Snake <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="keyword">super</span>(name); &#125;</span><br><span class="line">    move(distanceInMeters = <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Slithering..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Horse <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="keyword">super</span>(name); &#125;</span><br><span class="line">    move(distanceInMeters = <span class="number">45</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Galloping..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">"Sammy the Python"</span>);</span><br><span class="line"><span class="keyword">let</span> tom: Animal = <span class="keyword">new</span> Horse(<span class="string">"Tommy the Palomino"</span>);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(<span class="number">34</span>);</span><br><span class="line"><span class="comment">// console: </span></span><br><span class="line"><span class="comment">//Slithering...</span></span><br><span class="line"><span class="comment">//Sammy the Python moved 5m.</span></span><br><span class="line"><span class="comment">//Galloping...</span></span><br><span class="line"><span class="comment">//Tommy the Palomino moved 34m</span></span><br></pre></td></tr></table></figure><p>​ 在我们的例子中，我们能够很随意的访问到我们声明在程序中的变量（例子中的move方法等），如果你熟悉别的具有“类”（class）的编程语言，那么你就会发现我们并未使用<code>public</code>这样的关键字就可以去访问它。例如，C＃要求将每个成员明确标记为公开以便可见。 在TypeScript中，每个成员默认都是公共的。</p><p>​ 默认是<code>public</code>，我们也可以显式的去标明它是<code>public</code>的。就像下面这个例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">    <span class="keyword">public</span> move(distanceInMeters: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1、理解private"><a href="#1、理解private" class="headerlink" title="1、理解private"></a>1、理解private</h5><p>​ 那么，如果我们将公共设为私有（private），那会是什么效果：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">"Cat"</span>).name; <span class="comment">// Error: 'name' is private;</span></span><br></pre></td></tr></table></figure><p>​ <code>TypeScript</code>是一个结构类型系统。 当我们比较两种不同的类型时，不管它们来自哪里，如果所有成员的类型都是兼容的，那么我们说这些类型本身是兼容的。用下面这个例子来看：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> P1 &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> toEat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> P2 &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> toEat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> P1(<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> P2(<span class="string">'lisi'</span>);</span><br><span class="line">p1 = p2;	<span class="comment">//正确，虽然是两个不同的对象，但是彼此成员变量类型一致</span></span><br></pre></td></tr></table></figure><p>​ 再看一下修改后的代码，我们仅仅修改一下其中一个变量名：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> P1 &#123;</span><br><span class="line">    <span class="keyword">public</span> name1: <span class="built_in">string</span>;	<span class="comment">//这里修改下变量名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name1 = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> toEat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> P2 &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> toEat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> P1(<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> P2(<span class="string">'lisi'</span>);</span><br><span class="line">p1 = p2;	<span class="comment">//Error: Assigned expression type P2 is not assignable to type P1</span></span><br></pre></td></tr></table></figure><p>​ 在修改其中一个变量类型：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> P1 &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">number</span>;	<span class="comment">//这里修改其类型为number</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> toEat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> P2 &#123;</span><br><span class="line">    <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> toEat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> P1(<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> P2(<span class="string">'lisi'</span>);</span><br><span class="line">p1 = p2;	<span class="comment">//Error: Assigned expression type P2 is not assignable to type P1</span></span><br></pre></td></tr></table></figure><p>​ 此时，应该就理解了上面那串晦涩的表达，强类型系统的TS判断两个类型是否相同是通过判断两者成员变量是否兼容，这里的兼容意思就是变量名相同、变量类型具备包含关系。</p><p>​ 但是，在比较具有私有和受保护成员的类型时，我们对这些类型的处理方式不同。 对于被认为兼容的两种类型，如果其中一个类型具有私有成员，则另一个必须有一个私有成员并源于相同的声明。 这同样适用于受保护的成员。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rhino <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123; <span class="keyword">super</span>(<span class="string">"Rhino"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">"Goat"</span>);</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino();</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>);</span><br><span class="line"></span><br><span class="line">animal = rhino;</span><br><span class="line">animal = employee; <span class="comment">// Error: 'Animal' and 'Employee' are not compatible</span></span><br></pre></td></tr></table></figure><p>​ 这里，我们声明了三个类，其中<code>Rhino</code>是通过继承<code>Animal</code>而来的，所以我们在new出对象后，将<code>rhino</code>赋给<code>animal</code>是没有问题的，因为两个是兼容的，但是将将<code>employee</code>赋给<code>animal</code>就出现问题，尽管从上面兼容来看，两者的成员变量名称、类型都是相同的，应该是相互兼容的，但是<code>employee</code>中的那个成员变量<code>name</code>是<code>private</code>的，它并不是我们声明在<code>Animal</code>里面的那个<code>name</code>。</p><h5 id="2、理解受保护protected"><a href="#2、理解受保护protected" class="headerlink" title="2、理解受保护protected"></a>2、理解受保护protected</h5><p>​ <code>protected</code>修饰符和私有<code>private</code>修饰符很像，但也有所区别，看下面这个例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(howard.getElevatorPitch());</span><br><span class="line"><span class="built_in">console</span>.log(howard.name); <span class="comment">// error：Protected member is not accessible</span></span><br></pre></td></tr></table></figure><p>​ 这里，我们不能在<code>Person</code>的外面使用变量<code>name</code>，但是我们依然能在<code>Employee</code>的成员方法中使用它，这是因为<code>Employee</code>继承于<code>Person</code>。</p><p>​ 当然，类的构造函数也可以是受保护的，这就意味着你不能在外面去实例化它，但是它还是可以继承的。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123; <span class="keyword">this</span>.name = theName; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee can extend Person</span></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> department: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">"Howard"</span>, <span class="string">"Sales"</span>);</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>); <span class="comment">// Error: The 'Person' constructor is protected</span></span><br></pre></td></tr></table></figure><h4 id="二、理解组件中的修饰符"><a href="#二、理解组件中的修饰符" class="headerlink" title="二、理解组件中的修饰符"></a>二、理解组件中的修饰符</h4><p>​ 在讲之前，我们讨论个问题，Angular组件中的模板到底属不属于组件声明的<code>class</code>类中的成员变量。这里最简单的方法就是看一下Angular一个组件被编译后的结构：</p><p>​ 这里我们有一个<code>HelloComponent</code>组件（该组件选自于<code>Vapp-common2</code>中示例组件）:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    selector: <span class="string">'vapp-hello'</span>,</span><br><span class="line">    templateUrl: <span class="string">'./hello.component.html'</span>,</span><br><span class="line">    styleUrls: [<span class="string">'./hello.component.scss'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HelloComponent <span class="keyword">implements</span> OnInit &#123;</span><br><span class="line">    <span class="keyword">public</span> message: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = <span class="string">'@vapp/common2'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> myClick(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 直观上我们看到模板是在<code>class</code>外的，应该是不属于内部成员的，现在我们看一下编译(使用原生Angular编译器ngc)后的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloComponent = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">HelloComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    HelloComponent.prototype.ngOnInit = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = <span class="string">'@vapp/common2'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    HelloComponent.prototype.myClick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> HelloComponent;</span><br><span class="line">&#125;());</span><br><span class="line">HelloComponent.decorators = [</span><br><span class="line">    &#123; <span class="attr">type</span>: Component, <span class="attr">args</span>: [&#123;</span><br><span class="line">                selector: <span class="string">'vapp-hello'</span>,</span><br><span class="line">                template: <span class="string">"&lt;div class=\"hello\" (click)=\"myClick()\"&gt;\n    hello, &#123;&#123;message&#125;&#125;\n&lt;/div&gt;\n"</span>,</span><br><span class="line">                styles: [<span class="string">".hello&#123;color:red&#125;"</span>]</span><br><span class="line">            &#125;,] &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>​ 从编译后的<code>js</code>中，我们看到了组件的一些特性属性通过<code>decorators</code>挂载到<code>HelloComponent</code>对象上。在这里我们注意到了，组件中的修饰符<code>public</code>已经没有了，因为<code>js</code>中确实没有这类修饰符啊，那么，这些修饰符到底是在哪里用到的呢？？</p><p>​ 带着这个问题，我们来了解下Angular的编译器<code>ngc</code>，这个编译器封装了<code>ts</code>的编译器<code>tsc</code>，你可能已经猜到了，<code>tsc</code>是用来编译<code>ts</code>代码的，那么<code>ngc</code>肯定就是先转换Angular代码为<code>ts</code>代码，然后在转换为<code>js</code>代码。</p><p>​ 说到这里，就要引出编译方式了！我们将编译时间不同将Angular的编辑分为两种机制：AOT和JIT。</p><ul><li><code>AOT</code>： <code>Ahead-of-Time</code>, 这里的时间Time就是指运行时间，所以这个AOT理解为运行前编译</li></ul><ul><li><p><code>JIT</code>：<code>Just-in-Time</code>，这个则就是运行时编译的意思了</p><p>​这里两者详细工作步骤就不一一说明了，跳出本文话题太远。</p><p>​不过，有一个概念必须知道，那就是我们的修饰符（private、public….）只在编译时期存在，它是不存在运行时期（runtime）的。我们在上面两个机制说了他们都会进行<code>Angular</code>编译器<code>ngc</code>编译的过程，但由于时机不同，出现的情况也不同：</p></li><li><p>JIT：这种模式中浏览器编译的是<code>js</code>代码，我们知道<code>js</code>代码是不关心修饰符的（因为它没有）</p></li><li>AOT：这种模式是在本地编译成ts代码后，再次通过编译直接生成<code>js</code>代码的，而就在这个过程中，变量之前的获取、访问、赋值等一系列操作是基于<code>ts</code>的，因为这意味着修饰符在此时决定变量的使用范围。我们最开始有段<code>HelloComponent</code>的代码，编译之后的代码其实就可以看出Angular的模板（视图）信息是通过封装一个对象挂载到<code>HelloComponent</code>上的，这个对象实际就是视图（上下文）对象，思考一下，两个不同对象访问对方具有修饰符作用的成员变量才产出什么样的火花？？</li></ul><h4 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h4><p>​ 废话说了这么多，其实总结起来就两句话，组件模板对应组件Class类中应该使用public，无论是<code>AOT</code>（这个确实一定要用public）还是<code>JIT</code>(这个虽然无所谓，但是public单词更帅嘛)。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux续：Observable与Change Detection</title>
    <url>/2017/11/16/ngrx-store%E7%BB%AD/</url>
    <content><![CDATA[<!-- build time:Tue Apr 07 2020 20:01:07 GMT+0800 (GMT+08:00) --><p>​ 上一篇说到Redux在Angular中的使用，之后再研究Angular检测机制的时候有了新的理解，针对其Angular何时刷新、检测机制等问题进行讨论。</p><h4 id="一、Angular中的检测机制"><a href="#一、Angular中的检测机制" class="headerlink" title="一、Angular中的检测机制"></a>一、Angular中的检测机制</h4><p>​ 上次提到Redux（代码：<a href="https://git.coding.net/zhang121923/redux-test.git）中store属于单向数据流，在state发生变化之后我们使用输入属性@Input来触发更新，其实这点说法有误，在说明该问题之前，我们了解一下Angular的检测机制。" target="_blank" rel="noopener">https://git.coding.net/zhang121923/redux-test.git）中store属于单向数据流，在state发生变化之后我们使用输入属性@Input来触发更新，其实这点说法有误，在说明该问题之前，我们了解一下Angular的检测机制。</a></p><p>​ 在Angular中，Angular为每一个组件创建一个change detection（改变检测），就像Angular组件树一样，整个Angular检测也能类比为一棵树，当内部数发生变化时触发检测，Angular会从根开始从上向下遍历全部子组件进行检测触发页面更新。稍微提一下，Angular使用Zone.js监听异步变更数据，然后通知Angular执行变化检测。</p><p>​ 所以，根据上述，只要其数据（data）发生变化，就能触发检测从而刷新页面显示。上次demo代码中使用输入属性：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Input</span>(<span class="string">'loginState$'</span>) loginState$: Observable&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"><span class="meta">@Input</span>(<span class="string">'usersState$'</span>) usersState$ : Observable&lt;<span class="built_in">any</span>&gt;;</span><br></pre></td></tr></table></figure><p>​ 其语法没错，也确实可以这样使用，但是并不是解释此种方式是用来触发更新的，真正的触发更新其实只需要在reducer函数中返回新对象：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> DO_LOGIN: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;isLogining: <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​ 意味着触发change detection只需数据发生变化，包括对象只改变属性值（除Observable对象）。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">template ： <span class="string">'&lt;h2&gt;&#123;&#123;person&#125;&#125;&lt;/h2&gt;'</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> XX &#123;</span><br><span class="line">  <span class="keyword">private</span> person;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">this</span>.person = &#123;</span><br><span class="line">  		name: <span class="string">'zhangsan'</span>,</span><br><span class="line">      	age: <span class="number">20</span></span><br><span class="line">    &#125;	  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  changeData()&#123;</span><br><span class="line">  	<span class="keyword">this</span>.person.name = <span class="string">'lisi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 当触发changeData函数时，即使是属性改变依然触发change detection。</p><h4 id="二、OnPush策略"><a href="#二、OnPush策略" class="headerlink" title="二、OnPush策略"></a>二、OnPush策略</h4><p>​ 前面说过，变化检测一旦被触发，Angular将会从根组件从上向下遍历全部子树进行检测，虽然Angular在VM性能处理方面做了很多优化，使得即使遍历全部子树都有很棒的性能，但是这样无疑也浪费了部分性能，所以Angular提供了一个叫做<code>ChangeDetectionStrategy</code>的东西，可以让我们来决定它是否采用前面这种默认的变化检测。</p><p>​ <code>ChangeDetectionStrategy</code>提供了两种方式供我们选择：<code>OnPush</code>和<code>Default</code>，当然默认使用的就是这个<code>Default</code>（即前面这种方式），现在我们来看看<code>OnPush</code>。</p><p>​ <code>OnPush</code>策略采用的检测方式是：只取决于输入属性（熟不熟悉？？就是这个@Input），意味着本组件需不需要更新模板，只依赖于组件中的输入属性数据是否发生变化。</p><p>​ 当然，有个前提：这个输入属性是否改变的判断依据是其引用是否发生变化，在Angular的core包中有一个用于检测、更新绑定的方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAndUpdateBinding</span>(<span class="params">view, def, bindingIdx, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkBinding(view, def, bindingIdx, value)) &#123;</span><br><span class="line">        view.oldValues[def.bindingIndex + bindingIdx] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其方法依赖于<code>checkBinding</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkBinding</span>(<span class="params">view, def, bindingIdx, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="comment">/** @type &#123;?&#125; */</span> oldValues = view.oldValues;</span><br><span class="line">    <span class="keyword">if</span> ((view.state &amp; <span class="number">2</span> <span class="comment">/* FirstCheck */</span>) ||</span><br><span class="line">        !looseIdentical(oldValues[def.bindingIndex + bindingIdx], value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法依赖于一个叫做“宽松的相同”方法<code>looseIdentical</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">looseIdentical</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a === b || <span class="keyword">typeof</span> a === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> b === <span class="string">'number'</span> &amp;&amp; <span class="built_in">isNaN</span>(a) &amp;&amp; <span class="built_in">isNaN</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 可以看出，用于判定数据变化是靠引用来判定的。</p><p>​ 只要输入属性引用发生变化，就能触发change detection。这也是为什么reducer中要返回新state的原因了（这应该是原因之一）。</p><p>​ 在之前的demo中，我使用<code>| async</code>管道符在父组件模板中标注输入属性，其实这并不是解决刷新模板的根本原理，前面说过了，<code>OnPush</code>策略下真正刷新模板只取决于输入属性引用的变化。但是，这里遇到一个问题：Observable对象是个“不可变对象”（immutable ）,这么说应该更清楚：输入属性是一个Observable对象，当状态改变时返回的依旧是一个Observable对象，根据上面的判断，这变化了没有？没有！！，压根没有变化你还想让Angular更新模板？？</p><p>​ 那怎么办？我又想提高性能使用<code>OnPush</code>策略，又需要使用Observable流，好在Angular提供了一个方法，让我们在这种情况下主动触发提醒Angular进行改变检测，这个关键点就是：<code>ChangeDetectorRef</code>。</p><p>​ 正如名字，它实则就是改变检测change detection的一个引用，我们通过这个东西，就可以在监听到状态改变后主动触发改变检测，其核心方法是：<code>markForCheck()</code>:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> cd:ChangeDetectorRef</span>) &#123;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit()&#123;</span><br><span class="line">    <span class="keyword">this</span>.loginState$.subscribe(&#123;</span><br><span class="line">      next: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loginInfo = state.isLogining;</span><br><span class="line">        <span class="keyword">this</span>.cd.markForCheck();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.usersState$.subscribe(&#123;</span><br><span class="line">      next: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.users = state;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><pre><code>通过依赖注入ChangeDetectionRef对象，然后在我们认为需要更新模板的地方调用`markForCheck()`方法。
</code></pre><p><strong>当然，你也可以不使用OnPush策略，那么Angular会“自动刷新“的</strong></p><h4 id="三、freeze模块"><a href="#三、freeze模块" class="headerlink" title="三、freeze模块"></a>三、freeze模块</h4><p>​ 最后稍微提一下freeze模块，在上次的demo中，使用到了<code>ngrx-store-freeze</code>模块，起初只是听说其是用于校验<code>ngrx-store</code>语法的并没有测试，这次在验证Angular的change detection时发现了其作用。</p><p>​ 例如：我们在不使用该模块时，在reducer中我们可以这么写：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loginRedcer = <span class="function">(<span class="params">state = initialState.loginState, &#123;<span class="keyword">type</span>, payload&#125;: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">case</span> DO_LOGIN: &#123;</span><br><span class="line">      state.isLogining = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 这里我们并未返回一个新的state，这无论是Redux概念上的错误，而且这样也不能得到想要的结果（肯定啊，本质都搞错还想要正确的结果？？）。但是，要命的是，这个错并没有任何提示，代码依旧能正常运行，只是没有结果。</p><p>​ 所以<code>ngrx-store-freeze</code>的意义就有了，它有三个作用在它的官方说明中：</p><ul><li><p>Recursively freezes the <strong>current state</strong>, the dispatched <strong>action payload</strong> if provided and the <strong>new state</strong>.</p></li><li><p>When mutation occurs, an exception will be thrown.</p></li><li><p>Should be used <strong>only in development</strong> to ensure that the state remains immutable.</p><p>​说明白了，它就是用于校验Redux语法糖的，并且只是开发模式下有效。</p><p>​所以如果我们使用这个模块，那么使用上述的代码就会在浏览器控制台发出如下错误：</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TypeError</span>: Cannot assign to read only property <span class="string">'isLogining'</span> <span class="keyword">of</span> object <span class="string">'[object Object]'</span></span><br></pre></td></tr></table></figure><p>​ 这个提示（state只能是只读的）应该就是Redux的标准说明了吧？</p><p>​ 所以这个有利于我们开发，即便你是清楚Redux概念的，但不怕一万。。。。</p><p>本文是<a href="http://zhang121923.coding.me/2017/11/05/%E5%85%B3%E4%BA%8ERedux%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener"><strong>Redux的学习：Angular中@ngrx/store的概念以及使用</strong></a>一文的后续研究</p><p>demo地址：<a href="https://git.coding.net/zhang121923/redux-test.git" target="_blank" rel="noopener">https://git.coding.net/zhang121923/redux-test.git</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux的学习：Angular中@ngrx/store的概念以及使用</title>
    <url>/2017/11/05/%E5%85%B3%E4%BA%8ERedux%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<!-- build time:Tue Apr 07 2020 20:01:07 GMT+0800 (GMT+08:00) --><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>​ 在介绍@ngrx/store概念之前，先提出一个问题：如果现在一个前端项目中在多个页面多个组件中存在一个关联关系，某处数据改变就可能导致该关联关系中所有的依赖发生改变，你会怎么做？咱们来列一列：</p><ul><li><p>使用全局一个变量来控制关联关系</p></li><li><p>创建一个公有服务来控制关联关系</p></li><li><p>使用浏览器的cookie、storage等</p></li><li><p>ext（Angular中组件事件、输入输出…..）</p><p>​说了这么多方法，意味着什么？就拿一个大型前端项目开发时，多个代码生产者可能就会按照自己的喜好来处理上述类似的问题，那么代码混乱不说，就之后代码的扩展、维护也都是一个大坑。又有人说那我们统一使用一种方式就行了呗！没错，这样肯定也行的，但一旦项目庞大，就会存在很多我们自己都能预测到的问题。<br>​所以，@ngrx/store就解决了这样一个问题，它关注的重点就是状态（数据）的改变、数据变化时的流通。它有以下特点：</p></li></ul><ul><li>数据源单一：整个应用只有一个store</li><li>所有数据只读，修改只能通过dispatch一个action改变</li><li>使用Reducer纯函数接收一个状态（state）,返回一个新状态</li></ul><p>这些store、action、state又是什么？下面我们来了解。</p><p>注：下文所有代码来自我实际demo，地址是：<a href="https://coding.net/u/zhang121923/p/redux-test/git" target="_blank" rel="noopener">https://coding.net/u/zhang121923/p/redux-test/git</a></p><h4 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h4><p>​ 在使用之前，我们了解一点概念：（记住他们的格式）</p><h5 id="2-1、什么是store"><a href="#2-1、什么是store" class="headerlink" title="2.1、什么是store"></a>2.1、什么是store</h5><p>​ 官方说，这叫一颗状态树，所有的状态都挂载到这棵树上。在我认为，store好比一个数据库，它将作为我们一个应用的数据（状态）中心。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">StoreModule.providerStore(&#123;   <span class="comment">//这里就可以理解为Store是数据库，reducer是表</span></span><br><span class="line">      login:loginRedcer,</span><br><span class="line">      user:usersRducer</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​ 一个项目应该只有一个Store，所有的状态信息都可以按照逻辑划分挂载到状态树上。</p><p>（如下图所示一样，整个项目所有状态会有一个根state，其他所有的状态都会按逻辑挂载到根状态上。）</p><p>​ <img src="http://ow1s4ln40.bkt.clouddn.com/store-tree.png" alt="state树"></p><h5 id="2-2、什么叫状态（state）"><a href="#2-2、什么叫状态（state）" class="headerlink" title="2.2、什么叫状态（state）"></a>2.2、什么叫状态（state）</h5><p>​ 一句话，页面上显示的数据、控制状态、登录状态、按钮根据逻辑的可选可不选等等一系列，都叫做一个状态。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如我们将一个用户列表当做一个状态进行模拟</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AppStore &#123;	 <span class="comment">//一个store保存全部的状态信息</span></span><br><span class="line">  Users: User[] 		<span class="comment">//这个状态（数据）是以什么样的形式存在在我们项目中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 我们可以这样理解state，它其实就是一个用于表示状态信息的数据结构（类似model、java中的entity等）。</p><h5 id="2-3、什么是Reducer"><a href="#2-3、什么是Reducer" class="headerlink" title="2.3、什么是Reducer"></a>2.3、什么是Reducer</h5><p>​ 用我的理解，Reducer就是一个状态改变的触发器，由我们给定的动作来得到我们想要的状态（数据）。并且需要牢记的是：他是一个纯函数，接收一个状态和状态改变的动作，返回一个新的状态。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> userReducer = <span class="function">(<span class="params">state , &#123;<span class="keyword">type</span>,payload&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//根据行为返回一个新的状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在内部我们使用switch语句，根据type来做相应的事。</span></span><br></pre></td></tr></table></figure><p>看如图代码：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/reducer.png" alt="登录状态的Reducer"></p><p>​ 我们定义一个登录状态Ruducer，它可以根据不同的动作CHECK_LOGIN（检查是否登录）、DO_LOGIN（登录）、QUIT_LOGIN（退出）来做出相应处理，并返回给我们新的状态。</p><h5 id="2-4、什么是action"><a href="#2-4、什么是action" class="headerlink" title="2.4、什么是action"></a>2.4、什么是action</h5><p>​ action即动作，用于告诉状态树需要做什么，它的结构从上面的Reducer也看出来了：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Action&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>,</span><br><span class="line">  payload: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给一个实例action，比如我们要增加一个用户，那么我们的动作是：<br></p><figure class="highlight plain"><figcaption><span>: ADD_USER, payload: &#123;name: ‘zhangsan’, age: 12 &#125;&#125;```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- type代表这个动作的类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- payload代表我们完成该动作需要的负载参数</span><br><span class="line"></span><br><span class="line">#### 三、ngrx/store的使用方法</span><br><span class="line"></span><br><span class="line">##### 3.1、第一步：安装ngrx/store</span><br><span class="line"></span><br><span class="line">```yarn add @ngrx/store @ngrx/core -save</span><br></pre></td></tr></table></figure><p></p><p>​ 目前项目中我们还是使用ngrx/store的稳定版本V2.3.+，因为最新的版本可能会存在某些组件不支持的情况。</p><h5 id="3-2、第二步：创建state"><a href="#3-2、第二步：创建state" class="headerlink" title="3.2、第二步：创建state"></a>3.2、第二步：创建state</h5><p>​ 在项目构建初期，我们可能就需要根据需求分析所有的state状态的数据结构，并定义它们，例如我们会使用一个表示用户列表的状态，那么我们就需要定义该数据格式：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UserState &#123;</span><br><span class="line">Users :  user[]				<span class="comment">//user为我们定义的用户数组数据结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3、创建Reducer"><a href="#3-3、创建Reducer" class="headerlink" title="3.3、创建Reducer"></a>3.3、创建Reducer</h5><p>​ 根据state来定义该state的Reducer函数，一般每一个state状态对应一个Reducer函数。例如：我们有一个登录状态LoginState：<br>​ 它的state格式是： LoginState : {isLoging : boolean},<br>​ 它的Reducer处理检查登录状态、登入、退出动作：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loginRedcer = <span class="function">(<span class="params">state : LoginState , &#123;<span class="keyword">type</span>, payload&#125;: <span class="built_in">any</span></span>) 		=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> CHECK_LOGIN : &#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DO_LOGIN: &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;isLogining: <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> QUIT_LOGIN : &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;isLogining: !state&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>}<br>​ 其次，一般所有的动作（例如上面的CHECK_LOGIN、DO_LOGIN）通常是常量，用于区分动作类型，当项目规模较大时，我们可以单独使用一个文件来存放这些动作类型。</p><h5 id="3-4、根模块设置关联"><a href="#3-4、根模块设置关联" class="headerlink" title="3.4、根模块设置关联"></a>3.4、根模块设置关联</h5><p>在模块中引入@ngrx/store中的StoreModule模块，使用如下方法，将我们定义的state处理注入。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">imports: [</span><br><span class="line">    ...</span><br><span class="line">    StoreModule.provideStore(&#123; </span><br><span class="line">      login:loginRedcer</span><br><span class="line">    &#125;),</span><br><span class="line">  	...</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure><h5 id="3-5、获取状态数据"><a href="#3-5、获取状态数据" class="headerlink" title="3.5、获取状态数据"></a>3.5、获取状态数据</h5><p>​ 根据我们的业务逻辑，在响应的组件等订阅store。<br>例如，我们会在登录后的页面获取登录状态，则我们将会在该组件的构造器、ngOnInit钩子函数中订阅：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> store$: Store&lt;<span class="built_in">any</span>&gt;</span>) &#123;</span><br><span class="line">	<span class="keyword">this</span>.loginState$ = store$.select(<span class="string">'login'</span>);</span><br><span class="line">	<span class="keyword">this</span>.loginState$.subscribe(&#123;</span><br><span class="line"> 		 next: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">   			 <span class="keyword">this</span>.loginInfo = state.isLogining;</span><br><span class="line"> 		 &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者我们可能只需要在事件中订阅，例如如下一个点击事件中订阅：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">checkLoginClick() &#123;</span><br><span class="line">	<span class="keyword">this</span>.store.dispatch(&#123;<span class="keyword">type</span>: CHECK_LOGIN&#125;);</span><br><span class="line">	<span class="keyword">this</span>.login$.subscribe(&#123;</span><br><span class="line"> 		 next: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    		<span class="keyword">let</span> loginState = state.isLogining ? <span class="string">'成功'</span> : <span class="string">'失败'</span>;</span><br><span class="line">    		<span class="keyword">this</span>.utils.tip(<span class="string">'处于登录'</span> + loginState + <span class="string">'状态'</span>);</span><br><span class="line"> 		 &#125;</span><br><span class="line">	&#125;).unsubscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6、绑定模板进行模板刷新"><a href="#3-6、绑定模板进行模板刷新" class="headerlink" title="3.6、绑定模板进行模板刷新"></a>3.6、绑定模板进行模板刷新</h5><p>​ 单单在组件中订阅后就可以直接使用了吗？还不行，因为store数据流是一个单向数据流，意味着可能状态改变后数据确实是改变了，但是由于是单数据流它并不会导致页面模板刷新（这里可对比双向绑定概念理解但数据流）。所以，最后一步是我们需要将这种状态变化传递给组件模板，让模板知道当状态值改变时主动刷新模板显示。<br>那么什么方法可以触发模板刷新呢？在Angular中，我们能利用的就是组件的检测机制了！这里顺便提一下Angular的检测机制：我们都Angular是由组件构成的，每一个组件都会有自己的检测机制（可使用changeDetection来配置），而每当这个组件如果其输入属性改变，就会触发其组件模板改变。<br>​ 这里，我们使用组件输入属性@Input修饰器来做这件事：假设我们有一个组件：app-main-left，使用输入属性将我们将会发生改变的state注入其中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-main-left</span> [<span class="attr">login</span>]=<span class="string">"loginState$ | async"</span>&gt;</span><span class="tag">&lt;/<span class="name">app-main-left</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​ 这个<code>loginState$</code>就是我们前面说的store中的登录状态（为何用一个后缀$，因为每个状态是一个数据流，本质是Observable对象，我们一般使用这个后缀代表数据流）。<br>​ 而我们在app-main-left组件中就可以使用@Input装饰器接收这个loginState$数据流：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Input</span>() login: Observable&lt;<span class="built_in">any</span>&gt;;</span><br></pre></td></tr></table></figure><p>​ 这样一旦loginState$发生状态改变，就会主动提示组件模板的需要刷新了，是不是很方便？<br>​ 最后，提一下上面代码中的“| async”是个什么？“|”在Angular中表示管道符，可以简单的理解为数据的处理（类似filter、map等），而使用“async”代表的异步处理，会主动解析<code>loginState$</code>数据来更新模板，意味着如果没有这个“| async”，即使状态改变也是无法触发模板改变的。</p><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​ 本文主要结合自己的demo和学习，理解了该技术的核心，理解基础概念之后就不会很复杂，在demo实例中显示了本文用到的所有示例。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular style Encaption(样式封装)</title>
    <url>/2017/09/11/Angular-style-Encaption/</url>
    <content><![CDATA[<!-- build time:Tue Apr 07 2020 20:01:07 GMT+0800 (GMT+08:00) --><p>​ 在学习<code>Angular</code>组件的时候，跟个官方文档敲“英雄指南”时发现每一个组件中除了模板<code>template</code>还有一个<code>styles</code>或者<code>styleUrls</code>数组，一想就知道一定是样式了。回顾<code>VueJS</code>也是直接在组件中编写样式，但是清楚的是<code>VueJs</code>组件中的<code>&lt;style&gt;</code>标签可以明明白白的写上一个<code>scoped</code>关键字，用来表示本样式只用于本组件模板，那么在Angular中组件的样式是否有这样的作用域概念呢？</p><p>​ 话不多说，开始吧：</p><h4 id="一、小白举个栗子中看样式"><a href="#一、小白举个栗子中看样式" class="headerlink" title="一、小白举个栗子中看样式"></a>一、小白举个栗子中看样式</h4><p>​ 为了测试组件样式，我简单的使用Angular写了两个组件，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件1</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'my-comp1'</span>,</span><br><span class="line">  template: <span class="string">'&lt;h1&gt;这是组件1&lt;/h1&gt;'</span>,</span><br><span class="line">  styles: [<span class="string">'h1&#123;color: red&#125;'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent1</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件2</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'my-comp2'</span>,</span><br><span class="line">  template: <span class="string">'&lt;h1&gt;这是组件2&lt;/h1&gt;'</span>,</span><br><span class="line">  styles: [<span class="string">'h1&#123;color: aquamarine&#125;'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent2</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//全局style.css文件中设置h1标签</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 就是这么简单的配置，正确运行之后，页面显示如下：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/Angular%20style-1.PNG" alt></p><p>​ 明显可以看出来，它们各自使用了自己组件中定义的样式，这样看来貌似确实具有类似于<code>scoped</code>作用域的功能。然后再来看一下最后生成的HTML文件：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/Angular%20style-2.PNG" alt></p><p>奇怪，<code>_ngcontent-xx</code>这些是什么？？我们自己也没有在<code>css</code>中编写这个啊！别着急，下面我们就专门研究一下这个问题。</p><h4 id="二、样式封装"><a href="#二、样式封装" class="headerlink" title="二、样式封装"></a>二、样式封装</h4><p>​ 之所以有上面看到的不同组件不同样式情况，是因为在<code>Angular</code>中涉及到一个<code>shadow DOM</code>的概念。什么是<code>shadow DOM</code>？简单的说，它是用来封装我们私有的样式、隔绝外部样式的一个<code>隐藏</code>DOM（在主DOM树中是不存在的），更多<code>shadow DOM</code>细节请自行查阅。</p><p>​ Angular就大致利用这个原理来实现样式的封装，但是我们来看看浏览器对<code>shadow DOM</code>的支持情况：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/Angular%20style-3.PNG" alt></p><p>​ 情况这么不好，那怎么用啊？现在就得说一说本文的重点了：ViewEncapsulation</p><h4 id="三、ViewEncapsulation-视图封装"><a href="#三、ViewEncapsulation-视图封装" class="headerlink" title="三、ViewEncapsulation 视图封装"></a>三、ViewEncapsulation 视图封装</h4><p>​ 上面说了，既然<code>shadow DOM</code>好多浏览器不兼容但是我们就是要用，怎么办？</p><p>​ 所以，<code>ViewEncapsulation</code>就是这么来的啊！Angular自行将<code>shadow DOM</code>封装成了一个工具，这样我们就可以无需考虑浏览器兼容而直接去使用它。在Angular中有三种视图封装类型：</p><ol><li><p>ViewEncapsulation.None：不使用<code>shadow DOM</code>，所以就没有样式封装</p></li><li><p>ViewEncapsulation.Emulated：不使用<code>shadow DOM</code>，但是使用样式仿真来达到效果</p></li><li><p>ViewEncapsulation.Native：使用本机原生的<code>shadow DOM</code></p><p>​下面让我们来详细了解一下下这三个类型：</p></li></ol><h5 id="3-1、ViewEncapsulation-None"><a href="#3-1、ViewEncapsulation-None" class="headerlink" title="3.1、ViewEncapsulation.None"></a>3.1、ViewEncapsulation.None</h5><p>​ 我们将不使用<code>shadow DOM</code>来进行样式封装，代码走起来，为了效果明显(为什么？之后会提到)我们在上面例子中的所有组件(包括<code>app.component.ts</code>、组件1、组件2)上添加<code>ViewEncapsulation.None</code>属性，例如在组件2中添加如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component, ViewEncapsulation&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  encapsulation: ViewEncapsulation.None,	<span class="comment">//就是在这里添加ViewEncapsulation配置</span></span><br><span class="line">  selector: <span class="string">'my-comp2'</span>,</span><br><span class="line">  template: <span class="string">'&lt;h1&gt;这是组件2&lt;/h1&gt;'</span>,</span><br><span class="line">  styles: [<span class="string">'h1&#123;color: aquamarine&#125;'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent2</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 运行之后，页面是这样：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/Angular%20style-5.PNG" alt></p><p>​ 为什么成这样了？先让我们来看看生成的HTML页面详细结构，这一次包括<code>&lt;head&gt;</code>标签内：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/Angular%20style-6.PNG" alt></p><p>​ 现在清楚了吧？使用<code>ViewEncapsulation.None</code>是将我们组件中定义的样式”原封不动“的放到了<code>head</code>标签中，本例中全部是<code>h1</code>标签样式，所以以最后一个样式为准，页面上所有<code>h1</code>文本显示海蓝色。</p><h5 id="3-2、ViewEncapsulation-Emulated"><a href="#3-2、ViewEncapsulation-Emulated" class="headerlink" title="3.2、ViewEncapsulation.Emulated"></a>3.2、ViewEncapsulation.Emulated</h5><p>​ 我们最开始例子中未加入任何<code>ViewEncapsulation</code>字段，但是达到了样式封装的效果，是为什么？是因为Angular中默认使用<code>ViewEncapsulation.Emulated</code>配置。</p><p>​ 还是最开始未添加<code>ViewEncapsulation</code>的例子，当初我们并没有看详细的HTML（包括<code>&lt;head&gt;</code>内），这次我们重点看看：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/Angular%20style-7.PNG" alt></p><p>​ 看到这些<code>_ngcontent-XX</code>字段了吗？原来<code>ViewEncapsulation.Emulated</code>是将我们组件中的样式换了一个独一无二的名字，然后添加到<code>&lt;head&gt;</code>标签中去。这样，就达到了样式封装，神奇吧？</p><p>​ 说到这，稍微提一下，这种方式和我们知道的<code>CSS Modules</code>用法一致，将我们私有的样式名改成唯一的名字来达到样式唯一的效果。更多详细<code>CSS Modules</code>用法，请参考<a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html" target="_blank" rel="noopener">阮一峰的CSS Modules用法</a>。</p><h5 id="3-2、ViewEncapsulation-Native"><a href="#3-2、ViewEncapsulation-Native" class="headerlink" title="3.2、ViewEncapsulation.Native"></a>3.2、ViewEncapsulation.Native</h5><p>​ 这次我们将3.1中的<code>ViewEncapsulation.None</code>全部换成<code>ViewEncapsulation.Native</code>，运行效果如下：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/Angular%20style-8.PNG" alt></p><p>​ 可以看到效果是实现了样式封装，下面我们看看详细的HTML结构(注：在chrome浏览器中)：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/Angular%20style-9.PNG" alt></p><p>​ 我们可以看到，组件的样式并未加入<code>&lt;head&gt;</code>标签，所以样式肯定不是全局的，但是在<code>&lt;body&gt;</code>标签中我们清楚的看到了有一个<code>#shadow-root(open)</code>的东西，这个是在chrome浏览器F12开发者工具中设置<code>shadow DOM</code>可见达到的效果，设置如下：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/Angular%20style-4.PNG" alt></p><p>​ 言归正传，通过<code>ViewEncapsulation.Native</code>，实际上我们是使用了浏览器自身的<code>shadow DOM</code>特性，所以我们的组件就被封装成了一个”影子DOM“被注入到HTML文本中，而这种<code>shadow DOM</code>隔绝了外部对它的影响，从而达到样式私有的目的。但是缺点也存在，如下：</p><ul><li><code>ViewEncapsulation.Native</code>只能在支持<code>shadow DOM</code>浏览器中使用，例如上面的例子，我在火狐浏览器中压根就看不到任何东西。</li><li>使用<code>ViewEncapsulation.Native</code>封装的组件，是没办法通过<code>js</code>来获取的，例如：我在组件2中添加如下代码：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component, ViewEncapsulation, AfterViewInit&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line">declare <span class="keyword">var</span> $: any;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'my-comp2'</span>,</span><br><span class="line">  template: <span class="string">'&lt;h1 id="comp2"&gt;这是组件2&lt;/h1&gt;'</span>, 	<span class="comment">//这里我增加了id</span></span><br><span class="line">  styles: [<span class="string">'h1&#123;color: aquamarine&#125;'</span>],</span><br><span class="line">  encapsulation: ViewEncapsulation.Native,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent2</span> <span class="title">implements</span> <span class="title">AfterViewInit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngAfterViewInit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这个comp2的标签找到了没？：'</span>,$(<span class="string">"#comp2"</span>).length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 这段代码意思就是让组件被初始化加载之后能够找到<code>id=comp2</code>这个<code>&lt;h1&gt;</code>标签，直接使用<code>jQuery</code>的选择器将其输出出来，运行之后，咱们看看控制台打印出啥了：</p><p><img src="http://ow1s4ln40.bkt.clouddn.com/Angular%20style-10.PNG" alt></p><p>​ 看到没？？是0！！压根就获取不了这个标签，这是因为<code>shadow DOM</code>只能浏览器能识别，我们是无法通过代码获取的原因。还是那句话，更多<code>shadow DOM</code>细节请自行查阅，本文就不细说这个了。</p><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>​ 通过本文，是否能让你对Angular组件样式封装有更多的理解呢？？总之一句话，Angular中将<code>shadow DOM</code>封装成了<code>ViewEncapsulation</code>，它具备三种类型，分别是<code>None</code>、<code>Emulated</code>和<code>Native</code>。只要理解了这三个，在使用中就能得心应手。快去试试吧！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中一个神奇的WeakMap</title>
    <url>/2017/08/24/ES6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%A5%87%E7%9A%84WeakMap/</url>
    <content><![CDATA[<!-- build time:Tue Apr 07 2020 20:01:07 GMT+0800 (GMT+08:00) --><p>​ 这两天在项目中使用<code>ES6</code>中的<code>Map</code>数据结构时，接触到了一个新的类似Map结构的数据类型：<code>WeakMap</code>。它的用法与<code>Map</code>相仿，只是区别也很大，下面稍微整理了一下。</p><h4 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h4><p>​ 同<code>Map</code>一样，两者对比如下：</p><table><thead><tr><th style="text-align:center">属性和方法</th><th style="text-align:center">Map</th><th style="text-align:center">WeakMap</th></tr></thead><tbody><tr><td style="text-align:center">生成新对象</td><td style="text-align:center">new Map()</td><td style="text-align:center">new WeakMap()</td></tr><tr><td style="text-align:center">设置键值对</td><td style="text-align:center">set(key,value)</td><td style="text-align:center">set(key,value)</td></tr><tr><td style="text-align:center">获取键</td><td style="text-align:center">get(key)</td><td style="text-align:center">get(key)</td></tr><tr><td style="text-align:center">是否存在</td><td style="text-align:center">has(key)</td><td style="text-align:center">has(key)</td></tr><tr><td style="text-align:center">删除键</td><td style="text-align:center">delete(key)</td><td style="text-align:center">delete(key)</td></tr><tr><td style="text-align:center">清空所有键</td><td style="text-align:center">clear()</td><td style="text-align:center">无clear方法</td></tr><tr><td style="text-align:center">成员大小</td><td style="text-align:center">size</td><td style="text-align:center">无size属性</td></tr></tbody></table><p>​ 为什么没有size属性和clear方法？区别里面说！</p><h4 id="二、由来和区别"><a href="#二、由来和区别" class="headerlink" title="二、由来和区别"></a>二、由来和区别</h4><h5 id="2-1-结构的唯一区别"><a href="#2-1-结构的唯一区别" class="headerlink" title="2.1 结构的唯一区别"></a>2.1 结构的唯一区别</h5><p>​ <code>weakMap</code>和<code>Map</code>的结构相似，但是唯一的区别就在于：<code>weakMap</code>只接收对象作为键名(除null)，不能使用原始类型作为键名。</p><h5 id="2-2-由来"><a href="#2-2-由来" class="headerlink" title="2.2 由来"></a>2.2 由来</h5><p>​ 为什么已经有了<code>Map</code>，还要设计一个<code>WeakMap</code>？它的设计目的在于，键名是对象的弱引用，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">wMap.set(<span class="number">1</span>,<span class="string">'hello'</span>);	<span class="comment">//TypeError: Invalid value used as weak map key</span></span><br><span class="line">wMap.set(<span class="built_in">Symbol</span>(),<span class="string">'hello'</span>);		<span class="comment">//TypeError: Invalid value used as weak map key</span></span><br><span class="line"><span class="comment">//说明基本类型、Symbol类型都不可作为键名</span></span><br></pre></td></tr></table></figure><p>而弱引用是不计入垃圾回收机制的，所以其所对应的对象可能就会被自动回收。一旦对象被回收，<code>WeakMap</code>就会自动移除对应键值对。</p><p>​ 比如我们使用一个DOM元素作为<code>WeakMap</code>结构，当某个DOM元素被移除，其对应的<code>WeakMap</code>记录就会被自动移除。</p><p>​ 一般来说<code>WeakMap</code>的专用场合就是：它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄露。</p><p>​ 来看看这个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"root"</span>&gt;</span><br><span class="line">    &lt;P&gt;<span class="number">1</span>&lt;<span class="regexp">/P&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> wMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)[<span class="number">0</span>];</span><br><span class="line">    wMap.set(ele,<span class="string">'hello'</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>).removeChild(ele);</span><br><span class="line">    ele = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'获取的值是：'</span>, wMap.get(ele));		<span class="comment">//获取的值是： undefined</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>​ 可以看到，当我们删除<code>p</code>元素后，其<code>ele</code>所对应的键也自动消失了，再次引用该键名就只能返回<code>undefined</code>。</p><p>​ 就是因为键名不被计入这个特性，所以<code>WeakMap</code>就没有<code>size</code>属性和<code>clear</code>方法，同样也就不具备遍历操作(key()、values()、entries()，以及forEach等方法)。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">   <span class="keyword">var</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);</span><br><span class="line">   <span class="keyword">var</span> a = &#123;<span class="string">'a'</span>:<span class="number">1</span>&#125;;</span><br><span class="line">   wMap.set(ele,<span class="string">'hello'</span>);</span><br><span class="line">   wMap.set(a,<span class="string">'hello'</span>);</span><br><span class="line">   <span class="comment">//wMap.clear();		//TypeError: wMap.clear is not a function</span></span><br><span class="line">   <span class="comment">//wMap.forEach(function(value,key,wMap)&#123;//TypeError: wMap.forEach is not a function</span></span><br><span class="line">	<span class="comment">//console.log(key+':'+value)</span></span><br><span class="line">   <span class="comment">//&#125;);</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中混淆到我的几个“包含”</title>
    <url>/2017/08/23/JS%E4%B8%AD%E6%B7%B7%E6%B7%86%E5%88%B0%E6%88%91%E7%9A%84%E5%87%A0%E4%B8%AA%E2%80%9C%E5%8C%85%E5%90%AB%E2%80%9D/</url>
    <content><![CDATA[<!-- build time:Tue Apr 07 2020 20:01:07 GMT+0800 (GMT+08:00) --><p>​ 记性这么差的我并且之前一直坚信这几个“包含”应该是简单、易记的，但是后来发现还是自己犯了人生三大错觉。所以吸取教训，这一次彻底的整理一次<code>Javascript</code>中我们所遇到的包含。整理时主要遇到的就下面你看到的这些，如果文中有没有提到的、你还知道的“包含”，还请提示我一下！</p><p>​ 好了，闲不说，下面开始！</p><h4 id="1、indexOf：最基础的“包含”"><a href="#1、indexOf：最基础的“包含”" class="headerlink" title="1、indexOf：最基础的“包含”"></a>1、indexOf：最基础的“包含”</h4><p>​ 该方法可用于数组和字符串。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">Array</th><th style="text-align:center">String</th></tr></thead><tbody><tr><td style="text-align:left">函数</td><td style="text-align:center"><code>Array.prototype.indexOf(element[,fromIndex])</code></td><td style="text-align:center"><code>String.prototype.indexOf(searchStr[,fromIndex])</code></td></tr><tr><td style="text-align:left">参数</td><td style="text-align:center">element：元素 fromIndex：起始索引</td><td style="text-align:center">searchStr：检索的字符串 fromIndex：起始索引</td></tr><tr><td style="text-align:left">返回值</td><td style="text-align:center">找到的第一个元素的下标，无则为-1</td><td style="text-align:center">指定值的第一次出现的索引，无则返回-1</td></tr><tr><td style="text-align:left">fromIndex</td><td style="text-align:center">大于或等于数组长度，返回值为-1；为负值表示从数组尾部（-1开始）开始查找</td><td style="text-align:center">大于或等于，同数组返回-1，除非searchStr为空字符串则返回字符串总长度；为负时则查找整个字符串</td></tr><tr><td style="text-align:left">大小写</td><td style="text-align:center">X</td><td style="text-align:center">区分大小写</td></tr></tbody></table><p>​ 兼容性：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Chrome</th><th style="text-align:center">fireFox</th><th style="text-align:center">IE</th><th style="text-align:center">Opera</th><th style="text-align:center">safari</th></tr></thead><tbody><tr><td style="text-align:center">字符串</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">数组</td><td style="text-align:center">Y</td><td style="text-align:center">1.5</td><td style="text-align:center">9</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr></tbody></table><blockquote><p>更多细节请参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank" rel="noopener">数组</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf" target="_blank" rel="noopener">字符串</a></p></blockquote><h4 id="2、in关键字"><a href="#2、in关键字" class="headerlink" title="2、in关键字"></a>2、in关键字</h4><p>​ <code>in</code>的字面意思是‘在xxx中’、‘属于’等名词，所以这自然而然和”包含“有关系。在JS中，经常能看到<code>in</code>关键字，例如<code>for...in</code>语句中的还是接下来我们会涉及的”包含“意义的。</p><p>​ 我们还是从数组和对象两这来分辨<code>in</code>的用法：</p><h5 id="2-1、对象"><a href="#2-1、对象" class="headerlink" title="2.1、对象"></a>2.1、对象</h5><p>​ 在对象中，<code>in</code>代表在某个对象中是否包含某个属性，有则返回<code>true</code>，无则返回<code>false</code>。来看个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">'a'</span> : <span class="number">1</span> , <span class="string">'b'</span> : <span class="number">2</span>&#125;;</span><br><span class="line">obj.__proto__.c = <span class="number">3</span>;	<span class="comment">//ES6</span></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> obj;				<span class="comment">//true</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> obj; 				<span class="comment">//false</span></span><br><span class="line"><span class="string">'c'</span> <span class="keyword">in</span> obj;				<span class="comment">//true</span></span><br><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> obj		<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>​ 从此得出：<code>in</code>表示某属性名是否属于某对象，包含对象原型链上的属性。其实这一点在<code>for...in</code>语句上也体现了出来，它会将对象的全部属性包含原型链上的所有属性全部遍历一遍。</p><p>​ 兼容性：</p><table><thead><tr><th style="text-align:center">Chrome</th><th style="text-align:center">FireFox</th><th style="text-align:center">IE</th><th style="text-align:center">Opera</th><th style="text-align:center">Safari</th></tr></thead><tbody><tr><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr></tbody></table><h5 id="2-2、数组"><a href="#2-2、数组" class="headerlink" title="2.2、数组"></a>2.2、数组</h5><p>​ 数组的<code>in</code>与之类似，不过它查找的是数组索引是否有元素。看个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arry = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> arry;		<span class="comment">//true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> arry; 		<span class="comment">//true</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">in</span> arry;		<span class="comment">//false,数组最大下标为3，所以下标越界，返回false</span></span><br><span class="line"><span class="string">'length'</span> <span class="keyword">in</span> arry;	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> arry; 	<span class="comment">//true	ES6</span></span><br></pre></td></tr></table></figure><p>​ 与对象类似，它不仅会查找数组本身下标元素，还会查找对象原型上的所有属性。</p><p>​ 兼容性同上。</p><blockquote><p>更多细节，请查看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in" target="_blank" rel="noopener">in关键字</a></p></blockquote><h4 id="3、contains：字面意思真的是包含哈"><a href="#3、contains：字面意思真的是包含哈" class="headerlink" title="3、contains：字面意思真的是包含哈"></a>3、contains：字面意思真的是包含哈</h4><p>​ 就是因为其字面意思，我一度时间以为不论数组、字符串、对象都有该方法，但是。。。呵呵，还是怪自己。。。</p><p>​ 在此说明：对象和数组没有contains方法，对象和数组没有contains方法，对象和数组没有contains方法（敲三遍）。</p><p>​ However，DOM对象却具备这个方法：</p><h5 id="3-1、node-contains-otherNode"><a href="#3-1、node-contains-otherNode" class="headerlink" title="3.1、node.contains(otherNode)"></a>3.1、node.contains(otherNode)</h5><p>​ 含义：<code>node</code>节点中是否包含<code>otherNode</code>节点，是则返回<code>true</code>，否则返回<code>false</code>。来看这个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">"child"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div id="silbing"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'parent'</span>);</span><br><span class="line">  <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">'child'</span>);</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementById(<span class="string">'silbing'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(p.contains(c));	<span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(p.contains(s));	<span class="comment">//false</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>​ 兼容性：</p><table><thead><tr><th style="text-align:center">Chrome</th><th style="text-align:center">FireFox</th><th style="text-align:center">IE</th><th style="text-align:center">Opera</th><th style="text-align:center">Safari</th></tr></thead><tbody><tr><td style="text-align:center">Y</td><td style="text-align:center">9.0</td><td style="text-align:center">5.0</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr></tbody></table><h5 id="3-2、node-compareDocumentPosition-otherNode"><a href="#3-2、node-compareDocumentPosition-otherNode" class="headerlink" title="* 3.2、node.compareDocumentPosition(otherNode)"></a>* 3.2、node.compareDocumentPosition(otherNode)</h5><p>​ 谈到节点的关系，那就得提到这个方法了。确实很陌生，没怎么见过，但是人家可以有W3C正规血统，只是名字这…么…长…，在加上它的返回值最开始返回的是比特码，所以才这么不出名，但是要论真正的”定位“，那该方法确实比<code>contains</code>强太多了。</p><p>​ 直接上代码，先看看：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"parent"</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">"child"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div id="silbing"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'parent'</span>);</span><br><span class="line">  <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">'child'</span>);</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementById(<span class="string">'silbing'</span>);</span><br><span class="line">  alert(p.compareDocumentPosition(c))		<span class="comment">//打出：20</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>​ 纳闷了，为啥是20？？？这就是之前说的，它的返回值是比特码值的组合，具体全部看下表：</p><p>​ 方法：<code>node.compareDocumentPosition(otherNode)</code></p><table><thead><tr><th style="text-align:center">比特码</th><th style="text-align:center">十进制</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">1</td><td style="text-align:center">不再同一文档中</td></tr><tr><td style="text-align:center">0010</td><td style="text-align:center">2</td><td style="text-align:center">node在otherNode之后</td></tr><tr><td style="text-align:center">0100</td><td style="text-align:center">4</td><td style="text-align:center">node在otherNode之前</td></tr><tr><td style="text-align:center">1000</td><td style="text-align:center">8</td><td style="text-align:center">otherNode包含node</td></tr><tr><td style="text-align:center">10000</td><td style="text-align:center">16</td><td style="text-align:center">node包含otherNode</td></tr><tr><td style="text-align:center">100000</td><td style="text-align:center">32</td><td style="text-align:center">待定</td></tr></tbody></table><p>​ 现在知道为什么是20了吧？20 = 16 + 4；表示<code>parent</code>元素包含<code>child</code>元素，并且在<code>child</code>之前出现。</p><p>​ 兼容性：（毕竟是正规血统，兼容性很好，只是这万恶的IE……）</p><table><thead><tr><th style="text-align:center">Chrome</th><th style="text-align:center">FireFox</th><th style="text-align:center">IE</th><th style="text-align:center">Opera</th><th style="text-align:center">Safari</th></tr></thead><tbody><tr><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">9.0</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr></tbody></table><h4 id="4、includes"><a href="#4、includes" class="headerlink" title="4、includes"></a>4、includes</h4><p>​ 这个”包含“和最开始介绍的<code>in</code>有点像，不同的是它是数组中值、字符串中子串的检索。</p><h5 id="4-1、数组"><a href="#4-1、数组" class="headerlink" title="4.1、数组"></a>4.1、数组</h5><p>​ <code>Array.prototype.includes(ele[,fromIndex])</code>，表示<code>ele</code>元素是否包含在数组中，可选参数表示开始检索的下标。看看下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].includes(<span class="number">2</span>);		<span class="comment">//true</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);	<span class="comment">//true</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].includes(<span class="number">3</span>,<span class="number">3</span>);		<span class="comment">//false</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].includes(<span class="number">2</span>,<span class="number">-1</span>);		<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>​ 从测试代码可以看出：</p><ul><li><p>可以检索数组中某个值是否存在</p></li><li><p>可以检索数组中是否存在NaN</p></li><li><p>fromIndex如果大于等于数组长度，直接返回false，不予检索</p></li><li><p>fromIndex如果小于0，表示整个数组将会被检索</p><p>​兼容性：</p></li></ul><table><thead><tr><th style="text-align:center">Chrome</th><th style="text-align:center">FireFox</th><th style="text-align:center">IE</th><th style="text-align:center">Edge</th><th style="text-align:center">Opera</th><th style="text-align:center">Safari</th></tr></thead><tbody><tr><td style="text-align:center">47</td><td style="text-align:center">43</td><td style="text-align:center">N</td><td style="text-align:center">14</td><td style="text-align:center">34</td><td style="text-align:center">9</td></tr></tbody></table><h5 id="4-2、字符串"><a href="#4-2、字符串" class="headerlink" title="4.2、字符串"></a>4.2、字符串</h5><p>​ <code>str.includes(searchStr[,position])</code>，用于判断一个字符串是否包含在另一个字符串中，是返回<code>true</code>，否则返回<code>false</code>。</p><p>​ 该方法与<code>indexOf</code>类似，严格区分大小写。</p><p>​ 兼容性：</p><table><thead><tr><th style="text-align:center">Chrome</th><th style="text-align:center">FireFox</th><th style="text-align:center">IE</th><th style="text-align:center">Opera</th><th style="text-align:center">Safari</th></tr></thead><tbody><tr><td style="text-align:center">41</td><td style="text-align:center">40</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">9</td></tr></tbody></table><p>​ 冷知识：在FireFox 19~39中，该方法叫<code>contains()</code>，但是因为一个神奇的BUG冲突，所以才修改为<code>includes</code>。故事详情请查看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes" target="_blank" rel="noopener">详情</a></p><p>以上就是容易让我混淆的一系列”包含“，当然，肯定还有其他方法，例如<code>hasOwnProperty()</code>方法，但是这种方法意义就比较明显了。如有问题，忘各位指正。</p><p>夜深了，洗洗睡了！！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>angular指令中细节描述</title>
    <url>/2017/08/22/%E9%92%88%E5%AF%B9angular%E6%8C%87%E4%BB%A4%E4%B8%AD%E5%87%A0%E4%B8%AA%E7%BB%86%E8%8A%82%E9%98%90%E8%BF%B0/</url>
    <content><![CDATA[<!-- build time:Tue Apr 07 2020 20:01:07 GMT+0800 (GMT+08:00) --><h4 id="一、先谈angular加载"><a href="#一、先谈angular加载" class="headerlink" title="一、先谈angular加载"></a>一、先谈angular加载</h4><p>​ 在描述指令内部区别之前，咱们先说说angular在加载时都做了什么：</p><ol><li><p>页面加载时，当加载完angularJS所在的<code>&lt;script&gt;</code>后，angular就开始启动了，它会先创建一系列的工具、加载模块等（例如<code>bindJquery()</code>）。</p></li><li><p>在上一步的基础上，它会监听<code>DOMContentLoader</code>事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jqlite(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  angularInit(widow.document,bootstrap);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当发现DOM已加载完成时，angular将初始化启动整个angular项目，它重新遍历所有DOM，大致源代码如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">angularInit</span>(<span class="params">element,bootstrap</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> appElement,	<span class="comment">//定义ng-app根节点所在元素</span></span><br><span class="line">      model,	<span class="comment">//angular项目根名称，即ng-app的值</span></span><br><span class="line">      config=&#123;&#125;;	<span class="comment">//相关</span></span><br><span class="line">  forEach(ngAttrPrefixes,	<span class="comment">//ngAttrPrefixes=['ng-','data-ng-','ng:','x-ng-'];</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">prefix</span>)</span>&#123;</span><br><span class="line">  		<span class="keyword">var</span> name = prefix + <span class="string">'app'</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!appElement &amp;&amp; element.hasAttribute &amp;&amp; element.hasAttribute(name))&#123;</span><br><span class="line">  			appElement = element;</span><br><span class="line">          	model = element.getAttribute(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>这样就能找到angular项目根节点(<code>ng-app</code>)并启动它【注：若无该节点，angular希望我们手动启动，方法是<code>angular.bootstrap()</code>方法】。</p></li><li><p>在第1步的加载模块中(并不是DOM加载完成后哦，分清楚)，angularJS会为angular对象赋予很多特性方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">publishExternalAPI</span>(<span class="params">angular</span>)</span>&#123;</span><br><span class="line">  extend(angular,&#123;</span><br><span class="line">  	<span class="string">'bootstrap'</span>:bootstrap,</span><br><span class="line">    <span class="string">'bind'</span>:bind,</span><br><span class="line">    <span class="string">'element'</span>:jqLite,</span><br><span class="line">    <span class="comment">//等等一系列方法</span></span><br><span class="line">&#125;);</span><br><span class="line">  angularModule = setupModuleLoader(<span class="built_in">window</span>);<span class="comment">//配置angular的接口方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，在该方法中，就会为angular模块加载指令</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">angularModule(<span class="string">'ng'</span>,[<span class="string">'ngLocale'</span>],[<span class="string">'$provide'</span>,	<span class="comment">//加载ng模块，该模块依赖于ngLocale模块</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">ngModule</span>(<span class="params">$provide</span>)</span>&#123;</span><br><span class="line">  		$provide.provider(&#123;</span><br><span class="line">  			$$sanitizeUri: $$sanitizeUriProvider</span><br><span class="line">		&#125;);</span><br><span class="line">     	$provide.provider(<span class="string">'$compile'</span>,$compileProvider).</span><br><span class="line">        	directive(&#123;</span><br><span class="line">  				a: htmlAnchorDirective,</span><br><span class="line">          		ngBind: ngBindDirective,</span><br><span class="line">          		<span class="comment">//又是一系列自带的指令</span></span><br><span class="line">			&#125;).</span><br><span class="line">        	directive(&#123;</span><br><span class="line">  				ngInclude:ngIncludeFillContentDirective</span><br><span class="line">			&#125;).</span><br><span class="line">        	directive(ngAttributeAliasDirective).</span><br><span class="line">        	directive(ngEventDirective);<span class="comment">//终于完了</span></span><br><span class="line">   &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>上面的代码一大堆，重点就在这个<code>directive()</code>方法了。</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$compileProvider</span>(<span class="params">$provide,$$sanitizeUriProvider</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//省略一堆代码，直接看directive方法</span></span><br><span class="line">  <span class="keyword">this</span>.directive = <span class="function"><span class="keyword">function</span> <span class="title">registerDirective</span>(<span class="params">name,directiveFactory</span>)</span>&#123;</span><br><span class="line">  	<span class="comment">//验证信息，省</span></span><br><span class="line">    $provide.factory(name+suffix,[<span class="string">'$injector'</span>,<span class="string">'$exceptionHandler'</span>],<span class="comment">//suffix:Directive</span></span><br><span class="line">    	<span class="function"><span class="keyword">function</span>(<span class="params">$injector,$exceptionHandler</span>)</span>&#123;</span><br><span class="line">  			<span class="keyword">var</span> directives = [];</span><br><span class="line">      		forEach(hasDirective[name],<span class="function"><span class="keyword">function</span>(<span class="params">directiveFactory, index</span>)</span>&#123;</span><br><span class="line">  				<span class="keyword">try</span> &#123;</span><br><span class="line">  					<span class="keyword">var</span> directive = $injector.invoke(directiveFactory);</span><br><span class="line">                  	<span class="keyword">if</span>(isFunction(directive))&#123;		<span class="comment">//记住这组if-else代码，之后会用到</span></span><br><span class="line">  						directive = &#123;<span class="attr">compile</span>:valueFn(directive) &#125;;</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!directive.compile &amp;&amp; directive.link)&#123;</span><br><span class="line">  						directive.compile = valueFn(directive.link);</span><br><span class="line">					&#125;</span><br><span class="line">                  	directive.priority = directive.priority || <span class="number">0</span>;</span><br><span class="line">                  	<span class="comment">//设置一系列指令属性，包括index、name、require、restrict、$$moduleName</span></span><br><span class="line">                  	directives.push(directive);</span><br><span class="line">				&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  					$exceptionHandler(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">      		<span class="keyword">return</span> directives;</span><br><span class="line">		&#125;]);</span><br><span class="line">  	&#125;</span><br><span class="line">  	hasDirective[name].push(directiveFactory);</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">  		forEach(name, reverseParams(registerDirective));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从代码可以看出来，angular为我们提供了大量的指令，并且也提供了自定义指令。</p><h4 id="二、自定义指令中细节描述"><a href="#二、自定义指令中细节描述" class="headerlink" title="二、自定义指令中细节描述"></a>二、自定义指令中细节描述</h4><p>​ 前面说了很多，主要就是想给现在这一块做一个铺垫，现在让我们来回归原始话题，自定义指令说那些容易混淆的细节。</p><p>1、controller、compile、link的区别</p><p>​ 我们知道，在自定义指令中，有这三个方法，看上去样子差不多，之前刚接触angular时真的分不清这三者关系。现在我们具体来看看。</p><ul><li>从执行顺序上：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body ng-app=<span class="string">"myApp"</span> ng-controller=<span class="string">"myCtrl"</span>&gt;</span><br><span class="line">&lt;my-Directive&gt;&lt;/my-Directive&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    angular.module(<span class="string">'myApp'</span>,[])</span><br><span class="line">        .directive(<span class="string">'myDirective'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                compile:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="built_in">console</span>.log(<span class="string">'compile'</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                link:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'link'</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                controller:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'controller'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .controller(<span class="string">'myCtrl'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><p>其在控制台输出是这样的：</p><p><img src="C:\Users\Administrator.XTUVGARRQOSWDO7\Desktop\QQ截图20170716183252.png" alt="QQ截图20170716183252"></p><p>可以看到最先输出的时compile，controller之后输出，并未输出link。这个原因就在于之前源码里面的那一组让记住的<code>if-else</code>了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(isFunction(directive))&#123;		<span class="comment">//记住这组if-else代码，之后会用到</span></span><br><span class="line">  		directive = &#123;<span class="attr">compile</span>:valueFn(directive) &#125;;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!directive.compile &amp;&amp; directive.link)&#123;</span><br><span class="line">  		directive.compile = valueFn(directive.link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码应该就是直接是说明这个原因的关键了吧。</p><ul><li>从内部结构上：<br>我们知道，其实在从<code>compile</code>中，它返回了两个函数<code>preLink</code>与<code>postLink</code>，实际<code>link</code>函数就是<code>postLink</code>的演变，下面我会讲到链接函数的作用。​</li></ul><ul><li>从官方回答中看：<ul><li>compile：指令加载编译时运行，此时对它来说，</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>angularJs</tag>
      </tags>
  </entry>
  <entry>
    <title>angular爬坑日记</title>
    <url>/2017/08/21/angular%E7%88%AC%E5%9D%91%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<!-- build time:Tue Apr 07 2020 20:01:07 GMT+0800 (GMT+08:00) --><h3 id="一、angular实现原理略谈"><a href="#一、angular实现原理略谈" class="headerlink" title="一、angular实现原理略谈"></a>一、angular实现原理略谈</h3><p>​ 虽然业界将angular规划为<code>MVC</code>模式，但是它更有<code>MVVM</code>影子，其双向绑定就实现了<code>ViewModel</code>。下面聊聊我对angular实现原理的理解：</p><p>​ 1.1 浏览器加载HTML页面时，遇到外联<code>&lt;script&gt;</code>标签时会发出<code>HTTP</code>请求来下载该外部文件</p><p>​ 1.2 <code>angular.js</code>如此被下载下来，并监听页面<code>DomContentLoad</code>事件</p><p>​ 1.3 一旦<code>DomContentLoad</code>事件触发（即页面DOM加载完成）时，<code>angular</code>就开始执行</p><p>​ 1.4 <code>angular</code>会在页面中寻找<code>ng-app</code>字样标签，一旦找到则开始<code>angular</code>启动初始化（如果没有找到，<code>angualr</code>期望我们手动启动应用，需要使用<code>angular</code>的<code>bootstrap()</code>方法，即：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">Angular.bootstrap(ele,[<span class="string">'myApp'</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Angular.bootstrap(<span class="built_in">document</span>,[<span class="string">'myApp'</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>注意：bootstrap()方法只能启动angular应用一次）。</p></blockquote><p>​ 1.5 <code>angular</code>会在找到<code>ng-app</code>后 将其值配置injector服务。一旦程序加载完成，injector服务会配置<code>compile</code>服务，该服务的作用是遍历页面找到所有的指令将它们的链接函数合并为一个单一的链接函数，并将链接函数编译好的模板托付给<code>$rootScope</code>。</p><p>​ 1.6 <code>$rootScope</code>将在<code>angular</code>上下文中启动<code>$digest</code>脏循环并将其传播到子作用域中</p><p>​ 1.7 <code>$digest</code>会等待<code>$evalAsync</code>队列清空和<code>$watch</code>不再变化，此时才将整个修改后的DOM交给浏览器开始重新渲染显示。</p><h3 id="二、对脏检查与-apply的细节描述"><a href="#二、对脏检查与-apply的细节描述" class="headerlink" title="二、对脏检查与$apply的细节描述"></a>二、对脏检查与$apply的细节描述</h3><p>​ 2.1 页面进行双向绑定时，<code>scope</code>作用域会自动为其增加<code>watcher</code>函数监听值的变化，并自动调用<code>$scope.$apply()</code>。</p><p>​ 2.2 何时开始监听值的变化呢？这就是脏检查的产生原因。调用<code>$scope.$digest()</code>开始进入脏循环，会触发一系列watcher函数，一旦发生值的变化，就调用回调函数。</p><p>​ 2.3 <code>angular</code>会在上下文作用域中自动调用<code>$apply</code>进入脏循环，我们也可以手动调用<code>$scope.$digest</code>进入脏检测，或者调用<code>$scope.$apply()</code>方法，后者实际调用<code>$rootScope.$digest()</code>。</p><p>​ 2.4 何时需要手动调用进入脏检测呢？<code>angular</code>只负责将其上下文变更做出自动响应，但是如果我们在上下文之外（例如：JS代码修改、setTimeout等），就需要手动调用。</p><h3 id="三、代码爬坑"><a href="#三、代码爬坑" class="headerlink" title="三、代码爬坑"></a>三、代码爬坑</h3><p>3.1 ng-app启动Angular应用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = angular.module(<span class="string">'myApp'</span>,[]);</span><br></pre></td></tr></table></figure><ul><li><code>[ ]</code>:方括号表示该模块是否需要依赖某些模块。无论有无依赖，这个数组参数必须存在。</li></ul><p>3.2 自定义指令细节</p><p>​ 以代码为例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.directive(<span class="string">'myDirective'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$templateCache</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">  	restrict:<span class="string">'EACM'</span>,	<span class="comment">//分别代表元素、属性、类名、注释</span></span><br><span class="line">    template:<span class="string">''</span>,	<span class="comment">//可直接编写模板HTML代码，还可使用$templateCache.get('')获取外部文件</span></span><br><span class="line">    scope:&#123;</span><br><span class="line">  		XX:<span class="string">'='</span>,	<span class="comment">//实现父子域双向绑定，直接将子域该内容绑定到父域</span></span><br><span class="line">      	XX:<span class="string">'@'</span>, <span class="comment">//将子域中&#123;&#123;&#125;&#125;中的值单向绑定到父域，父域改变是子域会改变，但反之不行</span></span><br><span class="line">      	XX:<span class="string">'&amp;'</span>, <span class="comment">//将子域XX函数处理以及返回值绑定到父域函数执行</span></span><br><span class="line">	&#125;,</span><br><span class="line">    controller:<span class="function"><span class="keyword">function</span>(<span class="params">$scope,$element</span>)</span>&#123;&#125;,	<span class="comment">//注意三者参数名</span></span><br><span class="line">    link:<span class="function"><span class="keyword">function</span>(<span class="params">scope,el,attr</span>)</span>&#123;&#125;,</span><br><span class="line">    compile:<span class="function"><span class="keyword">function</span>(<span class="params">tElement,tAttrs,transclude</span>)</span>&#123;	<span class="comment">//此处参数可省略</span></span><br><span class="line">  		<span class="keyword">return</span> &#123;</span><br><span class="line">  			pre:<span class="function"><span class="keyword">function</span>(<span class="params">scope,iElement,iAttrs</span>)</span>&#123;&#125;,</span><br><span class="line">          	post:<span class="function"><span class="keyword">function</span>(<span class="params">scope,iElement,iAttrs</span>)</span>&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>link、controller、compile三者关系</p><p>controller先运行。如果link和compile都存在只运行compile（实际上link就是compile中的postLink函数）</p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>angularJs</tag>
      </tags>
  </entry>
</search>
