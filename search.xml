<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F27%2FAngular%E4%B8%AD%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[1234title: Angular中修饰符的研究date: 2018-10-21 22:29:51tags: [Angular,前端]categories: 前端Angular中修饰符的研究一、先从TypeScript中说起​ 先来看一个例子：12345678910111213141516171819202122232425262728293031323334class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log("Slithering..."); super.move(distanceInMeters); &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log("Galloping..."); super.move(distanceInMeters); &#125;&#125;let sam = new Snake("Sammy the Python");let tom: Animal = new Horse("Tommy the Palomino");sam.move();tom.move(34);// console: //Slithering...//Sammy the Python moved 5m.//Galloping...//Tommy the Palomino moved 34m​ 在我们的例子中，我们能够很随意的访问到我们声明在程序中的变量（例子中的move方法等），如果你熟悉别的具有“类”（class）的编程语言，那么你就会发现我们并未使用public这样的关键字就可以去访问它。例如，C＃要求将每个成员明确标记为公开以便可见。 在TypeScript中，每个成员默认都是公共的。​ 默认是public，我们也可以显式的去标明它是public的。就像下面这个例子：1234567class Animal &#123; public name: string; public constructor(theName: string) &#123; this.name = theName; &#125; public move(distanceInMeters: number) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;1、理解private​ 那么，如果我们将公共设为私有（private），那会是什么效果：123456class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;new Animal("Cat").name; // Error: 'name' is private;​ TypeScript是一个结构类型系统。 当我们比较两种不同的类型时，不管它们来自哪里，如果所有成员的类型都是兼容的，那么我们说这些类型本身是兼容的。用下面这个例子来看：123456789101112131415161718192021222324252627class P1 &#123; public name: string; constructor(name) &#123; this.name = name; &#125; public toEat() &#123; console.log(this.name); &#125;&#125;class P2 &#123; public name: string; constructor(name) &#123; this.name = name; &#125; public toEat() &#123; console.log(this.name); &#125;&#125;let p1 = new P1('zhangsan');let p2 = new P2('lisi');p1 = p2; //正确，虽然是两个不同的对象，但是彼此成员变量类型一致​ 再看一下修改后的代码，我们仅仅修改一下其中一个变量名：123456789101112131415161718192021222324252627class P1 &#123; public name1: string; //这里修改下变量名 constructor(name) &#123; this.name1 = name; &#125; public toEat() &#123; console.log(this.name1); &#125;&#125;class P2 &#123; public name: string; constructor(name) &#123; this.name = name; &#125; public toEat() &#123; console.log(this.name); &#125;&#125;let p1 = new P1('zhangsan');let p2 = new P2('lisi');p1 = p2; //Error: Assigned expression type P2 is not assignable to type P1​ 在修改其中一个变量类型：123456789101112131415161718192021222324252627class P1 &#123; public name: number; //这里修改其类型为number constructor(name) &#123; this.name = name; &#125; public toEat() &#123; console.log(this.name); &#125;&#125;class P2 &#123; public name: string; constructor(name) &#123; this.name = name; &#125; public toEat() &#123; console.log(this.name); &#125;&#125;let p1 = new P1('zhangsan');let p2 = new P2('lisi');p1 = p2; //Error: Assigned expression type P2 is not assignable to type P1​ 此时，应该就理解了上面那串晦涩的表达，强类型系统的TS判断两个类型是否相同是通过判断两者成员变量是否兼容，这里的兼容意思就是变量名相同、变量类型具备包含关系。​ 但是，在比较具有私有和受保护成员的类型时，我们对这些类型的处理方式不同。 对于被认为兼容的两种类型，如果其中一个类型具有私有成员，则另一个必须有一个私有成员并源于相同的声明。 这同样适用于受保护的成员。1234567891011121314151617181920class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super("Rhino"); &#125;&#125;class Employee &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let animal = new Animal("Goat");let rhino = new Rhino();let employee = new Employee("Bob");animal = rhino;animal = employee; // Error: 'Animal' and 'Employee' are not compatible​ 这里，我们声明了三个类，其中Rhino是通过继承Animal而来的，所以我们在new出对象后，将rhino赋给animal是没有问题的，因为两个是兼容的，但是将将employee赋给animal就出现问题，尽管从上面兼容来看，两者的成员变量名称、类型都是相同的，应该是相互兼容的，但是employee中的那个成员变量name是private的，它并不是我们声明在Animal里面的那个name。2、理解受保护protected​ protected修饰符和私有private修饰符很像，但也有所区别，看下面这个例子：123456789101112131415161718192021class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee("Howard", "Sales");console.log(howard.getElevatorPitch());console.log(howard.name); // error：Protected member is not accessible​ 这里，我们不能在Person的外面使用变量name，但是我们依然能在Employee的成员方法中使用它，这是因为Employee继承于Person。​ 当然，类的构造函数也可以是受保护的，这就意味着你不能在外面去实例化它，但是它还是可以继承的。123456789101112131415161718192021class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee can extend Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee("Howard", "Sales");let john = new Person("John"); // Error: The 'Person' constructor is protected二、理解组件中的修饰符​ 在讲之前，我们讨论个问题，Angular组件中的模板到底属不属于组件声明的class类中的成员变量。这里最简单的方法就是看一下Angular一个组件被编译后的结构：​ 这里我们有一个HelloComponent组件（该组件选自于Vapp-common2中示例组件）:1234567891011121314151617181920@Component(&#123; selector: 'vapp-hello', templateUrl: './hello.component.html', styleUrls: ['./hello.component.scss']&#125;)export class HelloComponent implements OnInit &#123; public message: string; constructor() &#123; &#125; ngOnInit() &#123; this.message = '@vapp/common2'; &#125; public myClick(): void &#123; console.log(this.message); &#125;&#125;​ 直观上我们看到模板是在class外的，应该是不属于内部成员的，现在我们看一下编译(使用原生Angular编译器ngc)后的代码：123456789101112131415161718var HelloComponent = /** @class */ (function () &#123; function HelloComponent() &#123; &#125; HelloComponent.prototype.ngOnInit = function () &#123; this.message = '@vapp/common2'; &#125;; HelloComponent.prototype.myClick = function () &#123; console.log(this.message); &#125;; return HelloComponent;&#125;());HelloComponent.decorators = [ &#123; type: Component, args: [&#123; selector: 'vapp-hello', template: "&lt;div class=\"hello\" (click)=\"myClick()\"&gt;\n hello, &#123;&#123;message&#125;&#125;\n&lt;/div&gt;\n", styles: [".hello&#123;color:red&#125;"] &#125;,] &#125;,];​ 从编译后的js中，我们看到了组件的一些特性属性通过decorators挂载到HelloComponent对象上。在这里我们注意到了，组件中的修饰符public已经没有了，因为js中确实没有这类修饰符啊，那么，这些修饰符到底是在哪里用到的呢？？​ 带着这个问题，我们来了解下Angular的编译器ngc，这个编译器封装了ts的编译器tsc，你可能已经猜到了，tsc是用来编译ts代码的，那么ngc肯定就是先转换Angular代码为ts代码，然后在转换为js代码。​ 说到这里，就要引出编译方式了！我们将编译时间不同将Angular的编辑分为两种机制：AOT和JIT。AOT： Ahead-of-Time, 这里的时间Time就是指运行时间，所以这个AOT理解为运行前编译JIT：Just-in-Time，这个则就是运行时编译的意思了​这里两者详细工作步骤就不一一说明了，跳出本文话题太远。​不过，有一个概念必须知道，那就是我们的修饰符（private、public….）只在编译时期存在，它是不存在运行时期（runtime）的。我们在上面两个机制说了他们都会进行Angular编译器ngc编译的过程，但由于时机不同，出现的情况也不同：JIT：这种模式中浏览器编译的是js代码，我们知道js代码是不关心修饰符的（因为它没有）AOT：这种模式是在本地编译成ts代码后，再次通过编译直接生成js代码的，而就在这个过程中，变量之前的获取、访问、赋值等一系列操作是基于ts的，因为这意味着修饰符在此时决定变量的使用范围。我们最开始有段HelloComponent的代码，编译之后的代码其实就可以看出Angular的模板（视图）信息是通过封装一个对象挂载到HelloComponent上的，这个对象实际就是视图（上下文）对象，思考一下，两个不同对象访问对方具有修饰符作用的成员变量才产出什么样的火花？？三、结论​ 废话说了这么多，其实总结起来就两句话，组件模板对应组件Class类中应该使用public，无论是AOT（这个确实一定要用public）还是JIT(这个虽然无所谓，但是public单词更帅嘛)。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redux续：Observable与Change Detection]]></title>
    <url>%2F2017%2F11%2F16%2Fngrx-store%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[​ 上一篇说到Redux在Angular中的使用，之后再研究Angular检测机制的时候有了新的理解，针对其Angular何时刷新、检测机制等问题进行讨论。一、Angular中的检测机制​ 上次提到Redux（代码：https://git.coding.net/zhang121923/redux-test.git）中store属于单向数据流，在state发生变化之后我们使用输入属性@Input来触发更新，其实这点说法有误，在说明该问题之前，我们了解一下Angular的检测机制。​ 在Angular中，Angular为每一个组件创建一个change detection（改变检测），就像Angular组件树一样，整个Angular检测也能类比为一棵树，当内部数发生变化时触发检测，Angular会从根开始从上向下遍历全部子组件进行检测触发页面更新。稍微提一下，Angular使用Zone.js监听异步变更数据，然后通知Angular执行变化检测。​ 所以，根据上述，只要其数据（data）发生变化，就能触发检测从而刷新页面显示。上次demo代码中使用输入属性：12@Input('loginState$') loginState$: Observable&lt;any&gt;;@Input('usersState$') usersState$ : Observable&lt;any&gt;;​ 其语法没错，也确实可以这样使用，但是并不是解释此种方式是用来触发更新的，真正的触发更新其实只需要在reducer函数中返回新对象：123case DO_LOGIN: &#123; return Object.assign(&#123;&#125;, state, &#123;isLogining: true&#125;); &#125;​ 意味着触发change detection只需数据发生变化，包括对象只改变属性值（除Observable对象）。1234567891011121314151617...template ： '&lt;h2&gt;&#123;&#123;person&#125;&#125;&lt;/h2&gt;'...class XX &#123; private person; constructor()&#123; this.person = &#123; name: 'zhangsan', age: 20 &#125; &#125; changeData()&#123; this.person.name = 'lisi'; &#125;&#125;​ 当触发changeData函数时，即使是属性改变依然触发change detection。二、OnPush策略​ 前面说过，变化检测一旦被触发，Angular将会从根组件从上向下遍历全部子树进行检测，虽然Angular在VM性能处理方面做了很多优化，使得即使遍历全部子树都有很棒的性能，但是这样无疑也浪费了部分性能，所以Angular提供了一个叫做ChangeDetectionStrategy的东西，可以让我们来决定它是否采用前面这种默认的变化检测。​ ChangeDetectionStrategy提供了两种方式供我们选择：OnPush和Default，当然默认使用的就是这个Default（即前面这种方式），现在我们来看看OnPush。​ OnPush策略采用的检测方式是：只取决于输入属性（熟不熟悉？？就是这个@Input），意味着本组件需不需要更新模板，只依赖于组件中的输入属性数据是否发生变化。​ 当然，有个前提：这个输入属性是否改变的判断依据是其引用是否发生变化，在Angular的core包中有一个用于检测、更新绑定的方法：1234567function checkAndUpdateBinding(view, def, bindingIdx, value) &#123; if (checkBinding(view, def, bindingIdx, value)) &#123; view.oldValues[def.bindingIndex + bindingIdx] = value; return true; &#125; return false;&#125;其方法依赖于checkBinding：12345678function checkBinding(view, def, bindingIdx, value) &#123; var /** @type &#123;?&#125; */ oldValues = view.oldValues; if ((view.state &amp; 2 /* FirstCheck */) || !looseIdentical(oldValues[def.bindingIndex + bindingIdx], value)) &#123; return true; &#125; return false;&#125;可以看到这个方法依赖于一个叫做“宽松的相同”方法looseIdentical：123function looseIdentical(a, b) &#123; return a === b || typeof a === 'number' &amp;&amp; typeof b === 'number' &amp;&amp; isNaN(a) &amp;&amp; isNaN(b);&#125;​ 可以看出，用于判定数据变化是靠引用来判定的。​ 只要输入属性引用发生变化，就能触发change detection。这也是为什么reducer中要返回新state的原因了（这应该是原因之一）。​ 在之前的demo中，我使用| async管道符在父组件模板中标注输入属性，其实这并不是解决刷新模板的根本原理，前面说过了，OnPush策略下真正刷新模板只取决于输入属性引用的变化。但是，这里遇到一个问题：Observable对象是个“不可变对象”（immutable ）,这么说应该更清楚：输入属性是一个Observable对象，当状态改变时返回的依旧是一个Observable对象，根据上面的判断，这变化了没有？没有！！，压根没有变化你还想让Angular更新模板？？​ 那怎么办？我又想提高性能使用OnPush策略，又需要使用Observable流，好在Angular提供了一个方法，让我们在这种情况下主动触发提醒Angular进行改变检测，这个关键点就是：ChangeDetectorRef。​ 正如名字，它实则就是改变检测change detection的一个引用，我们通过这个东西，就可以在监听到状态改变后主动触发改变检测，其核心方法是：markForCheck():123456789101112131415161718constructor(private cd:ChangeDetectorRef) &#123; &#125; ngAfterViewInit()&#123; this.loginState$.subscribe(&#123; next: state =&gt; &#123; this.loginInfo = state.isLogining; this.cd.markForCheck(); &#125; &#125;); this.usersState$.subscribe(&#123; next: state =&gt; &#123; this.users = state; &#125; &#125;); &#125;通过依赖注入ChangeDetectionRef对象，然后在我们认为需要更新模板的地方调用`markForCheck()`方法。 当然，你也可以不使用OnPush策略，那么Angular会“自动刷新“的三、freeze模块​ 最后稍微提一下freeze模块，在上次的demo中，使用到了ngrx-store-freeze模块，起初只是听说其是用于校验ngrx-store语法的并没有测试，这次在验证Angular的change detection时发现了其作用。​ 例如：我们在不使用该模块时，在reducer中我们可以这么写：12345678910export const loginRedcer = (state = initialState.loginState, &#123;type, payload&#125;: any) =&gt; &#123; switch (type) &#123; //..... case DO_LOGIN: &#123; state.isLogining = true; return state; &#125; //..... &#125;&#125;​ 这里我们并未返回一个新的state，这无论是Redux概念上的错误，而且这样也不能得到想要的结果（肯定啊，本质都搞错还想要正确的结果？？）。但是，要命的是，这个错并没有任何提示，代码依旧能正常运行，只是没有结果。​ 所以ngrx-store-freeze的意义就有了，它有三个作用在它的官方说明中：Recursively freezes the current state, the dispatched action payload if provided and the new state.When mutation occurs, an exception will be thrown.Should be used only in development to ensure that the state remains immutable.​说明白了，它就是用于校验Redux语法糖的，并且只是开发模式下有效。​所以如果我们使用这个模块，那么使用上述的代码就会在浏览器控制台发出如下错误：1TypeError: Cannot assign to read only property 'isLogining' of object '[object Object]'​ 这个提示（state只能是只读的）应该就是Redux的标准说明了吧？​ 所以这个有利于我们开发，即便你是清楚Redux概念的，但不怕一万。。。。本文是Redux的学习：Angular中@ngrx/store的概念以及使用一文的后续研究demo地址：https://git.coding.net/zhang121923/redux-test.git]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux的学习：Angular中@ngrx/store的概念以及使用]]></title>
    <url>%2F2017%2F11%2F05%2F%E5%85%B3%E4%BA%8ERedux%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、前言​ 在介绍@ngrx/store概念之前，先提出一个问题：如果现在一个前端项目中在多个页面多个组件中存在一个关联关系，某处数据改变就可能导致该关联关系中所有的依赖发生改变，你会怎么做？咱们来列一列：使用全局一个变量来控制关联关系创建一个公有服务来控制关联关系使用浏览器的cookie、storage等ext（Angular中组件事件、输入输出…..）​说了这么多方法，意味着什么？就拿一个大型前端项目开发时，多个代码生产者可能就会按照自己的喜好来处理上述类似的问题，那么代码混乱不说，就之后代码的扩展、维护也都是一个大坑。又有人说那我们统一使用一种方式就行了呗！没错，这样肯定也行的，但一旦项目庞大，就会存在很多我们自己都能预测到的问题。​所以，@ngrx/store就解决了这样一个问题，它关注的重点就是状态（数据）的改变、数据变化时的流通。它有以下特点：数据源单一：整个应用只有一个store所有数据只读，修改只能通过dispatch一个action改变使用Reducer纯函数接收一个状态（state）,返回一个新状态这些store、action、state又是什么？下面我们来了解。注：下文所有代码来自我实际demo，地址是：https://coding.net/u/zhang121923/p/redux-test/git二、基本概念​ 在使用之前，我们了解一点概念：（记住他们的格式）2.1、什么是store​ 官方说，这叫一颗状态树，所有的状态都挂载到这棵树上。在我认为，store好比一个数据库，它将作为我们一个应用的数据（状态）中心。1234StoreModule.providerStore(&#123; //这里就可以理解为Store是数据库，reducer是表 login:loginRedcer, user:usersRducer&#125;)​ 一个项目应该只有一个Store，所有的状态信息都可以按照逻辑划分挂载到状态树上。（如下图所示一样，整个项目所有状态会有一个根state，其他所有的状态都会按逻辑挂载到根状态上。）​ 2.2、什么叫状态（state）​ 一句话，页面上显示的数据、控制状态、登录状态、按钮根据逻辑的可选可不选等等一系列，都叫做一个状态。1234//例如我们将一个用户列表当做一个状态进行模拟export interface AppStore &#123; //一个store保存全部的状态信息 Users: User[] //这个状态（数据）是以什么样的形式存在在我们项目中&#125;​ 我们可以这样理解state，它其实就是一个用于表示状态信息的数据结构（类似model、java中的entity等）。2.3、什么是Reducer​ 用我的理解，Reducer就是一个状态改变的触发器，由我们给定的动作来得到我们想要的状态（数据）。并且需要牢记的是：他是一个纯函数，接收一个状态和状态改变的动作，返回一个新的状态。1234export const userReducer = (state , &#123;type,payload&#125;) =&gt; &#123; //根据行为返回一个新的状态&#125;//在内部我们使用switch语句，根据type来做相应的事。看如图代码：​ 我们定义一个登录状态Ruducer，它可以根据不同的动作CHECK_LOGIN（检查是否登录）、DO_LOGIN（登录）、QUIT_LOGIN（退出）来做出相应处理，并返回给我们新的状态。2.4、什么是action​ action即动作，用于告诉状态树需要做什么，它的结构从上面的Reducer也看出来了：1234export interface Action&#123; type: string, payload: any&#125;我们给一个实例action，比如我们要增加一个用户，那么我们的动作是：: ADD_USER, payload: &#123;name: ‘zhangsan’, age: 12 &#125;&#125;```1234567891011- type代表这个动作的类型- payload代表我们完成该动作需要的负载参数#### 三、ngrx/store的使用方法##### 3.1、第一步：安装ngrx/store```yarn add @ngrx/store @ngrx/core -save​ 目前项目中我们还是使用ngrx/store的稳定版本V2.3.+，因为最新的版本可能会存在某些组件不支持的情况。3.2、第二步：创建state​ 在项目构建初期，我们可能就需要根据需求分析所有的state状态的数据结构，并定义它们，例如我们会使用一个表示用户列表的状态，那么我们就需要定义该数据格式：123export interface UserState &#123;Users : user[] //user为我们定义的用户数组数据结构&#125;3.3、创建Reducer​ 根据state来定义该state的Reducer函数，一般每一个state状态对应一个Reducer函数。例如：我们有一个登录状态LoginState：​ 它的state格式是： LoginState : {isLoging : boolean},​ 它的Reducer处理检查登录状态、登入、退出动作：1234567891011121314export const loginRedcer = (state : LoginState , &#123;type, payload&#125;: any) =&gt; &#123; switch (type) &#123; case CHECK_LOGIN : &#123; return state; &#125; case DO_LOGIN: &#123; return Object.assign(&#123;&#125;, state, &#123;isLogining: true&#125;); &#125; case QUIT_LOGIN : &#123; return Object.assign(&#123;&#125;, state, &#123;isLogining: !state&#125;) &#125; default: return state; &#125;}​ 其次，一般所有的动作（例如上面的CHECK_LOGIN、DO_LOGIN）通常是常量，用于区分动作类型，当项目规模较大时，我们可以单独使用一个文件来存放这些动作类型。3.4、根模块设置关联在模块中引入@ngrx/store中的StoreModule模块，使用如下方法，将我们定义的state处理注入。1234567imports: [ ... StoreModule.provideStore(&#123; login:loginRedcer &#125;), ... ],3.5、获取状态数据​ 根据我们的业务逻辑，在响应的组件等订阅store。例如，我们会在登录后的页面获取登录状态，则我们将会在该组件的构造器、ngOnInit钩子函数中订阅：12345678constructor(private store$: Store&lt;any&gt;) &#123; this.loginState$ = store$.select('login'); this.loginState$.subscribe(&#123; next: state =&gt; &#123; this.loginInfo = state.isLogining; &#125; &#125;);&#125;或者我们可能只需要在事件中订阅，例如如下一个点击事件中订阅：123456789checkLoginClick() &#123; this.store.dispatch(&#123;type: CHECK_LOGIN&#125;); this.login$.subscribe(&#123; next: state =&gt; &#123; let loginState = state.isLogining ? '成功' : '失败'; this.utils.tip('处于登录' + loginState + '状态'); &#125; &#125;).unsubscribe();&#125;3.6、绑定模板进行模板刷新​ 单单在组件中订阅后就可以直接使用了吗？还不行，因为store数据流是一个单向数据流，意味着可能状态改变后数据确实是改变了，但是由于是单数据流它并不会导致页面模板刷新（这里可对比双向绑定概念理解但数据流）。所以，最后一步是我们需要将这种状态变化传递给组件模板，让模板知道当状态值改变时主动刷新模板显示。那么什么方法可以触发模板刷新呢？在Angular中，我们能利用的就是组件的检测机制了！这里顺便提一下Angular的检测机制：我们都Angular是由组件构成的，每一个组件都会有自己的检测机制（可使用changeDetection来配置），而每当这个组件如果其输入属性改变，就会触发其组件模板改变。​ 这里，我们使用组件输入属性@Input修饰器来做这件事：假设我们有一个组件：app-main-left，使用输入属性将我们将会发生改变的state注入其中。1&lt;app-main-left [login]="loginState$ | async"&gt;&lt;/app-main-left&gt;​ 这个loginState$就是我们前面说的store中的登录状态（为何用一个后缀$，因为每个状态是一个数据流，本质是Observable对象，我们一般使用这个后缀代表数据流）。​ 而我们在app-main-left组件中就可以使用@Input装饰器接收这个loginState$数据流：1@Input() login: Observable&lt;any&gt;;​ 这样一旦loginState$发生状态改变，就会主动提示组件模板的需要刷新了，是不是很方便？​ 最后，提一下上面代码中的“| async”是个什么？“|”在Angular中表示管道符，可以简单的理解为数据的处理（类似filter、map等），而使用“async”代表的异步处理，会主动解析loginState$数据来更新模板，意味着如果没有这个“| async”，即使状态改变也是无法触发模板改变的。四、总结​ 本文主要结合自己的demo和学习，理解了该技术的核心，理解基础概念之后就不会很复杂，在demo实例中显示了本文用到的所有示例。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular style Encaption(样式封装)]]></title>
    <url>%2F2017%2F09%2F11%2FAngular-style-Encaption%2F</url>
    <content type="text"><![CDATA[​ 在学习Angular组件的时候，跟个官方文档敲“英雄指南”时发现每一个组件中除了模板template还有一个styles或者styleUrls数组，一想就知道一定是样式了。回顾VueJS也是直接在组件中编写样式，但是清楚的是VueJs组件中的&lt;style&gt;标签可以明明白白的写上一个scoped关键字，用来表示本样式只用于本组件模板，那么在Angular中组件的样式是否有这样的作用域概念呢？​ 话不多说，开始吧：一、小白举个栗子中看样式​ 为了测试组件样式，我简单的使用Angular写了两个组件，如下：12345678//组件1@Component(&#123; selector: 'my-comp1', template: '&lt;h1&gt;这是组件1&lt;/h1&gt;', styles: ['h1&#123;color: red&#125;']&#125;)export class MyComponent1 &#123;&#125;12345678//组件2@Component(&#123; selector: 'my-comp2', template: '&lt;h1&gt;这是组件2&lt;/h1&gt;', styles: ['h1&#123;color: aquamarine&#125;']&#125;)export class MyComponent2 &#123;&#125;1234//全局style.css文件中设置h1标签h1&#123; color: black;&#125;​ 就是这么简单的配置，正确运行之后，页面显示如下：​ 明显可以看出来，它们各自使用了自己组件中定义的样式，这样看来貌似确实具有类似于scoped作用域的功能。然后再来看一下最后生成的HTML文件：奇怪，_ngcontent-xx这些是什么？？我们自己也没有在css中编写这个啊！别着急，下面我们就专门研究一下这个问题。二、样式封装​ 之所以有上面看到的不同组件不同样式情况，是因为在Angular中涉及到一个shadow DOM的概念。什么是shadow DOM？简单的说，它是用来封装我们私有的样式、隔绝外部样式的一个隐藏DOM（在主DOM树中是不存在的），更多shadow DOM细节请自行查阅。​ Angular就大致利用这个原理来实现样式的封装，但是我们来看看浏览器对shadow DOM的支持情况：​ 情况这么不好，那怎么用啊？现在就得说一说本文的重点了：ViewEncapsulation三、ViewEncapsulation 视图封装​ 上面说了，既然shadow DOM好多浏览器不兼容但是我们就是要用，怎么办？​ 所以，ViewEncapsulation就是这么来的啊！Angular自行将shadow DOM封装成了一个工具，这样我们就可以无需考虑浏览器兼容而直接去使用它。在Angular中有三种视图封装类型：ViewEncapsulation.None：不使用shadow DOM，所以就没有样式封装ViewEncapsulation.Emulated：不使用shadow DOM，但是使用样式仿真来达到效果ViewEncapsulation.Native：使用本机原生的shadow DOM​下面让我们来详细了解一下下这三个类型：3.1、ViewEncapsulation.None​ 我们将不使用shadow DOM来进行样式封装，代码走起来，为了效果明显(为什么？之后会提到)我们在上面例子中的所有组件(包括app.component.ts、组件1、组件2)上添加ViewEncapsulation.None属性，例如在组件2中添加如下：1234567891011import &#123;Component, ViewEncapsulation&#125; from '@angular/core';@Component(&#123; encapsulation: ViewEncapsulation.None, //就是在这里添加ViewEncapsulation配置 selector: 'my-comp2', template: '&lt;h1&gt;这是组件2&lt;/h1&gt;', styles: ['h1&#123;color: aquamarine&#125;']&#125;)export class MyComponent2 &#123;&#125;​ 运行之后，页面是这样：​ 为什么成这样了？先让我们来看看生成的HTML页面详细结构，这一次包括&lt;head&gt;标签内：​ 现在清楚了吧？使用ViewEncapsulation.None是将我们组件中定义的样式”原封不动“的放到了head标签中，本例中全部是h1标签样式，所以以最后一个样式为准，页面上所有h1文本显示海蓝色。3.2、ViewEncapsulation.Emulated​ 我们最开始例子中未加入任何ViewEncapsulation字段，但是达到了样式封装的效果，是为什么？是因为Angular中默认使用ViewEncapsulation.Emulated配置。​ 还是最开始未添加ViewEncapsulation的例子，当初我们并没有看详细的HTML（包括&lt;head&gt;内），这次我们重点看看：​ 看到这些_ngcontent-XX字段了吗？原来ViewEncapsulation.Emulated是将我们组件中的样式换了一个独一无二的名字，然后添加到&lt;head&gt;标签中去。这样，就达到了样式封装，神奇吧？​ 说到这，稍微提一下，这种方式和我们知道的CSS Modules用法一致，将我们私有的样式名改成唯一的名字来达到样式唯一的效果。更多详细CSS Modules用法，请参考阮一峰的CSS Modules用法。3.2、ViewEncapsulation.Native​ 这次我们将3.1中的ViewEncapsulation.None全部换成ViewEncapsulation.Native，运行效果如下：​ 可以看到效果是实现了样式封装，下面我们看看详细的HTML结构(注：在chrome浏览器中)：​ 我们可以看到，组件的样式并未加入&lt;head&gt;标签，所以样式肯定不是全局的，但是在&lt;body&gt;标签中我们清楚的看到了有一个#shadow-root(open)的东西，这个是在chrome浏览器F12开发者工具中设置shadow DOM可见达到的效果，设置如下：​ 言归正传，通过ViewEncapsulation.Native，实际上我们是使用了浏览器自身的shadow DOM特性，所以我们的组件就被封装成了一个”影子DOM“被注入到HTML文本中，而这种shadow DOM隔绝了外部对它的影响，从而达到样式私有的目的。但是缺点也存在，如下：ViewEncapsulation.Native只能在支持shadow DOM浏览器中使用，例如上面的例子，我在火狐浏览器中压根就看不到任何东西。使用ViewEncapsulation.Native封装的组件，是没办法通过js来获取的，例如：我在组件2中添加如下代码：12345678910111213141516171819import &#123;Component, ViewEncapsulation, AfterViewInit&#125; from '@angular/core';declare var $: any;@Component(&#123; selector: 'my-comp2', template: '&lt;h1 id="comp2"&gt;这是组件2&lt;/h1&gt;', //这里我增加了id styles: ['h1&#123;color: aquamarine&#125;'], encapsulation: ViewEncapsulation.Native,&#125;)export class MyComponent2 implements AfterViewInit &#123; constructor() &#123; &#125; ngAfterViewInit() &#123; console.log('这个comp2的标签找到了没？：',$("#comp2").length); &#125;&#125;​ 这段代码意思就是让组件被初始化加载之后能够找到id=comp2这个&lt;h1&gt;标签，直接使用jQuery的选择器将其输出出来，运行之后，咱们看看控制台打印出啥了：​ 看到没？？是0！！压根就获取不了这个标签，这是因为shadow DOM只能浏览器能识别，我们是无法通过代码获取的原因。还是那句话，更多shadow DOM细节请自行查阅，本文就不细说这个了。四、总结​ 通过本文，是否能让你对Angular组件样式封装有更多的理解呢？？总之一句话，Angular中将shadow DOM封装成了ViewEncapsulation，它具备三种类型，分别是None、Emulated和Native。只要理解了这三个，在使用中就能得心应手。快去试试吧！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中一个神奇的WeakMap]]></title>
    <url>%2F2017%2F08%2F24%2FES6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%A5%87%E7%9A%84WeakMap%2F</url>
    <content type="text"><![CDATA[​ 这两天在项目中使用ES6中的Map数据结构时，接触到了一个新的类似Map结构的数据类型：WeakMap。它的用法与Map相仿，只是区别也很大，下面稍微整理了一下。一、基本用法​ 同Map一样，两者对比如下：属性和方法MapWeakMap生成新对象new Map()new WeakMap()设置键值对set(key,value)set(key,value)获取键get(key)get(key)是否存在has(key)has(key)删除键delete(key)delete(key)清空所有键clear()无clear方法成员大小size无size属性​ 为什么没有size属性和clear方法？区别里面说！二、由来和区别2.1 结构的唯一区别​ weakMap和Map的结构相似，但是唯一的区别就在于：weakMap只接收对象作为键名(除null)，不能使用原始类型作为键名。2.2 由来​ 为什么已经有了Map，还要设计一个WeakMap？它的设计目的在于，键名是对象的弱引用，1234var wMap = new WeakMap();wMap.set(1,'hello'); //TypeError: Invalid value used as weak map keywMap.set(Symbol(),'hello'); //TypeError: Invalid value used as weak map key//说明基本类型、Symbol类型都不可作为键名而弱引用是不计入垃圾回收机制的，所以其所对应的对象可能就会被自动回收。一旦对象被回收，WeakMap就会自动移除对应键值对。​ 比如我们使用一个DOM元素作为WeakMap结构，当某个DOM元素被移除，其对应的WeakMap记录就会被自动移除。​ 一般来说WeakMap的专用场合就是：它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄露。​ 来看看这个例子：1234567891011&lt;div id="root"&gt; &lt;P&gt;1&lt;/P&gt;&lt;/div&gt;&lt;script&gt; var wMap = new WeakMap(); var ele = document.getElementsByTagName('p')[0]; wMap.set(ele,'hello'); document.getElementById('root').removeChild(ele); ele = null; console.log('获取的值是：', wMap.get(ele)); //获取的值是： undefined&lt;/script&gt;​ 可以看到，当我们删除p元素后，其ele所对应的键也自动消失了，再次引用该键名就只能返回undefined。​ 就是因为键名不被计入这个特性，所以WeakMap就没有size属性和clear方法，同样也就不具备遍历操作(key()、values()、entries()，以及forEach等方法)。123456789var wMap = new WeakMap(); var ele = document.querySelector('p'); var a = &#123;'a':1&#125;; wMap.set(ele,'hello'); wMap.set(a,'hello'); //wMap.clear(); //TypeError: wMap.clear is not a function //wMap.forEach(function(value,key,wMap)&#123;//TypeError: wMap.forEach is not a function //console.log(key+':'+value) //&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中混淆到我的几个“包含”]]></title>
    <url>%2F2017%2F08%2F23%2FJS%E4%B8%AD%E6%B7%B7%E6%B7%86%E5%88%B0%E6%88%91%E7%9A%84%E5%87%A0%E4%B8%AA%E2%80%9C%E5%8C%85%E5%90%AB%E2%80%9D%2F</url>
    <content type="text"><![CDATA[​ 记性这么差的我并且之前一直坚信这几个“包含”应该是简单、易记的，但是后来发现还是自己犯了人生三大错觉。所以吸取教训，这一次彻底的整理一次Javascript中我们所遇到的包含。整理时主要遇到的就下面你看到的这些，如果文中有没有提到的、你还知道的“包含”，还请提示我一下！​ 好了，闲不说，下面开始！1、indexOf：最基础的“包含”​ 该方法可用于数组和字符串。ArrayString函数Array.prototype.indexOf(element[,fromIndex])String.prototype.indexOf(searchStr[,fromIndex])参数element：元素 fromIndex：起始索引searchStr：检索的字符串 fromIndex：起始索引返回值找到的第一个元素的下标，无则为-1指定值的第一次出现的索引，无则返回-1fromIndex大于或等于数组长度，返回值为-1；为负值表示从数组尾部（-1开始）开始查找大于或等于，同数组返回-1，除非searchStr为空字符串则返回字符串总长度；为负时则查找整个字符串大小写X区分大小写​ 兼容性：ChromefireFoxIEOperasafari字符串YYYYY数组Y1.59YY更多细节请参考：数组 字符串2、in关键字​ in的字面意思是‘在xxx中’、‘属于’等名词，所以这自然而然和”包含“有关系。在JS中，经常能看到in关键字，例如for...in语句中的还是接下来我们会涉及的”包含“意义的。​ 我们还是从数组和对象两这来分辨in的用法：2.1、对象​ 在对象中，in代表在某个对象中是否包含某个属性，有则返回true，无则返回false。来看个例子：123456var obj = &#123;'a' : 1 , 'b' : 2&#125;;obj.__proto__.c = 3; //ES6'a' in obj; //true1 in obj; //false'c' in obj; //true'toString' in obj //true​ 从此得出：in表示某属性名是否属于某对象，包含对象原型链上的属性。其实这一点在for...in语句上也体现了出来，它会将对象的全部属性包含原型链上的所有属性全部遍历一遍。​ 兼容性：ChromeFireFoxIEOperaSafariYYYYY2.2、数组​ 数组的in与之类似，不过它查找的是数组索引是否有元素。看个例子：123456var arry = [1,2,3,4];1 in arry; //true0 in arry; //true4 in arry; //false,数组最大下标为3，所以下标越界，返回false'length' in arry; //trueSymbol.iterator in arry; //true ES6​ 与对象类似，它不仅会查找数组本身下标元素，还会查找对象原型上的所有属性。​ 兼容性同上。更多细节，请查看：in关键字3、contains：字面意思真的是包含哈​ 就是因为其字面意思，我一度时间以为不论数组、字符串、对象都有该方法，但是。。。呵呵，还是怪自己。。。​ 在此说明：对象和数组没有contains方法，对象和数组没有contains方法，对象和数组没有contains方法（敲三遍）。​ However，DOM对象却具备这个方法：3.1、node.contains(otherNode)​ 含义：node节点中是否包含otherNode节点，是则返回true，否则返回false。来看这个例子：1234567891011&lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="silbing"&gt;&lt;/div&gt;&lt;script&gt; var p = document.getElementById('parent'); var c = document.getElementById('child'); var s = document.getElementById('silbing'); console.log(p.contains(c)); //true console.log(p.contains(s)); //false&lt;/script&gt;​ 兼容性：ChromeFireFoxIEOperaSafariY9.05.0YY* 3.2、node.compareDocumentPosition(otherNode)​ 谈到节点的关系，那就得提到这个方法了。确实很陌生，没怎么见过，但是人家可以有W3C正规血统，只是名字这…么…长…，在加上它的返回值最开始返回的是比特码，所以才这么不出名，但是要论真正的”定位“，那该方法确实比contains强太多了。​ 直接上代码，先看看：12345678910&lt;div id="parent"&gt; &lt;div id="child"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="silbing"&gt;&lt;/div&gt;&lt;script&gt; var p = document.getElementById('parent'); var c = document.getElementById('child'); var s = document.getElementById('silbing'); alert(p.compareDocumentPosition(c)) //打出：20&lt;/script&gt;​ 纳闷了，为啥是20？？？这就是之前说的，它的返回值是比特码值的组合，具体全部看下表：​ 方法：node.compareDocumentPosition(otherNode)比特码十进制含义00011不再同一文档中00102node在otherNode之后01004node在otherNode之前10008otherNode包含node1000016node包含otherNode10000032待定​ 现在知道为什么是20了吧？20 = 16 + 4；表示parent元素包含child元素，并且在child之前出现。​ 兼容性：（毕竟是正规血统，兼容性很好，只是这万恶的IE……）ChromeFireFoxIEOperaSafariYY9.0YY4、includes​ 这个”包含“和最开始介绍的in有点像，不同的是它是数组中值、字符串中子串的检索。4.1、数组​ Array.prototype.includes(ele[,fromIndex])，表示ele元素是否包含在数组中，可选参数表示开始检索的下标。看看下面代码：1234[1,2,3].includes(2); //true[1,2,3,NaN].includes(NaN); //true[1,2,3].includes(3,3); //false[1,2,3].includes(2,-1); //true​ 从测试代码可以看出：可以检索数组中某个值是否存在可以检索数组中是否存在NaNfromIndex如果大于等于数组长度，直接返回false，不予检索fromIndex如果小于0，表示整个数组将会被检索​兼容性：ChromeFireFoxIEEdgeOperaSafari4743N143494.2、字符串​ str.includes(searchStr[,position])，用于判断一个字符串是否包含在另一个字符串中，是返回true，否则返回false。​ 该方法与indexOf类似，严格区分大小写。​ 兼容性：ChromeFireFoxIEOperaSafari4140NN9​ 冷知识：在FireFox 19~39中，该方法叫contains()，但是因为一个神奇的BUG冲突，所以才修改为includes。故事详情请查看：详情以上就是容易让我混淆的一系列”包含“，当然，肯定还有其他方法，例如hasOwnProperty()方法，但是这种方法意义就比较明显了。如有问题，忘各位指正。夜深了，洗洗睡了！！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular指令中细节描述]]></title>
    <url>%2F2017%2F08%2F22%2F%E9%92%88%E5%AF%B9angular%E6%8C%87%E4%BB%A4%E4%B8%AD%E5%87%A0%E4%B8%AA%E7%BB%86%E8%8A%82%E9%98%90%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一、先谈angular加载​ 在描述指令内部区别之前，咱们先说说angular在加载时都做了什么：页面加载时，当加载完angularJS所在的&lt;script&gt;后，angular就开始启动了，它会先创建一系列的工具、加载模块等（例如bindJquery()）。在上一步的基础上，它会监听DOMContentLoader事件123jqlite(function()&#123; angularInit(widow.document,bootstrap);&#125;);当发现DOM已加载完成时，angular将初始化启动整个angular项目，它重新遍历所有DOM，大致源代码如下12345678910111213function angularInit(element,bootstrap)&#123; var appElement, //定义ng-app根节点所在元素 model, //angular项目根名称，即ng-app的值 config=&#123;&#125;; //相关 forEach(ngAttrPrefixes, //ngAttrPrefixes=['ng-','data-ng-','ng:','x-ng-']; function(prefix)&#123; var name = prefix + 'app'; if(!appElement &amp;&amp; element.hasAttribute &amp;&amp; element.hasAttribute(name))&#123; appElement = element; model = element.getAttribute(name); &#125; &#125;); &#125;​这样就能找到angular项目根节点(ng-app)并启动它【注：若无该节点，angular希望我们手动启动，方法是angular.bootstrap()方法】。在第1步的加载模块中(并不是DOM加载完成后哦，分清楚)，angularJS会为angular对象赋予很多特性方法123456789function publishExternalAPI(angular)&#123; extend(angular,&#123; 'bootstrap':bootstrap, 'bind':bind, 'element':jqLite, //等等一系列方法&#125;); angularModule = setupModuleLoader(window);//配置angular的接口方法&#125;并且，在该方法中，就会为angular模块加载指令123456789101112131415161718angularModule('ng',['ngLocale'],['$provide', //加载ng模块，该模块依赖于ngLocale模块 function ngModule($provide)&#123; $provide.provider(&#123; $$sanitizeUri: $$sanitizeUriProvider &#125;); $provide.provider('$compile',$compileProvider). directive(&#123; a: htmlAnchorDirective, ngBind: ngBindDirective, //又是一系列自带的指令 &#125;). directive(&#123; ngInclude:ngIncludeFillContentDirective &#125;). directive(ngAttributeAliasDirective). directive(ngEventDirective);//终于完了 &#125;]);上面的代码一大堆，重点就在这个directive()方法了。12345678910111213141516171819202122232425262728293031function $compileProvider($provide,$$sanitizeUriProvider)&#123; //省略一堆代码，直接看directive方法 this.directive = function registerDirective(name,directiveFactory)&#123; //验证信息，省 $provide.factory(name+suffix,['$injector','$exceptionHandler'],//suffix:Directive function($injector,$exceptionHandler)&#123; var directives = []; forEach(hasDirective[name],function(directiveFactory, index)&#123; try &#123; var directive = $injector.invoke(directiveFactory); if(isFunction(directive))&#123; //记住这组if-else代码，之后会用到 directive = &#123;compile:valueFn(directive) &#125;; &#125;else if(!directive.compile &amp;&amp; directive.link)&#123; directive.compile = valueFn(directive.link); &#125; directive.priority = directive.priority || 0; //设置一系列指令属性，包括index、name、require、restrict、$$moduleName directives.push(directive); &#125;catch (e) &#123; $exceptionHandler(e); &#125; &#125;); return directives; &#125;]); &#125; hasDirective[name].push(directiveFactory); &#125; else&#123; forEach(name, reverseParams(registerDirective)); &#125; return this;&#125;;从代码可以看出来，angular为我们提供了大量的指令，并且也提供了自定义指令。二、自定义指令中细节描述​ 前面说了很多，主要就是想给现在这一块做一个铺垫，现在让我们来回归原始话题，自定义指令说那些容易混淆的细节。1、controller、compile、link的区别​ 我们知道，在自定义指令中，有这三个方法，看上去样子差不多，之前刚接触angular时真的分不清这三者关系。现在我们具体来看看。从执行顺序上：12345678910111213141516171819202122&lt;body ng-app="myApp" ng-controller="myCtrl"&gt;&lt;my-Directive&gt;&lt;/my-Directive&gt;&lt;script&gt; angular.module('myApp',[]) .directive('myDirective',function()&#123; return &#123; compile:function()&#123; console.log('compile'); &#125;, link:function () &#123; console.log('link'); &#125;, controller:function () &#123; console.log('controller'); &#125; &#125; &#125;) .controller('myCtrl',function($scope)&#123; &#125;);&lt;/script&gt;&lt;/body&gt;其在控制台输出是这样的：可以看到最先输出的时compile，controller之后输出，并未输出link。这个原因就在于之前源码里面的那一组让记住的if-else了：12345if(isFunction(directive))&#123; //记住这组if-else代码，之后会用到 directive = &#123;compile:valueFn(directive) &#125;;&#125;else if(!directive.compile &amp;&amp; directive.link)&#123; directive.compile = valueFn(directive.link);&#125;这代码应该就是直接是说明这个原因的关键了吧。从内部结构上：我们知道，其实在从compile中，它返回了两个函数preLink与postLink，实际link函数就是postLink的演变，下面我会讲到链接函数的作用。​从官方回答中看：compile：指令加载编译时运行，此时对它来说，]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>angularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular爬坑日记]]></title>
    <url>%2F2017%2F08%2F21%2Fangular%E7%88%AC%E5%9D%91%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、angular实现原理略谈​ 虽然业界将angular规划为MVC模式，但是它更有MVVM影子，其双向绑定就实现了ViewModel。下面聊聊我对angular实现原理的理解：​ 1.1 浏览器加载HTML页面时，遇到外联&lt;script&gt;标签时会发出HTTP请求来下载该外部文件​ 1.2 angular.js如此被下载下来，并监听页面DomContentLoad事件​ 1.3 一旦DomContentLoad事件触发（即页面DOM加载完成）时，angular就开始执行​ 1.4 angular会在页面中寻找ng-app字样标签，一旦找到则开始angular启动初始化（如果没有找到，angualr期望我们手动启动应用，需要使用angular的bootstrap()方法，即：12var ele = document.createElement('div');Angular.bootstrap(ele,['myApp']);1Angular.bootstrap(document,['myApp']);注意：bootstrap()方法只能启动angular应用一次）。​ 1.5 angular会在找到ng-app后 将其值配置injector服务。一旦程序加载完成，injector服务会配置compile服务，该服务的作用是遍历页面找到所有的指令将它们的链接函数合并为一个单一的链接函数，并将链接函数编译好的模板托付给$rootScope。​ 1.6 $rootScope将在angular上下文中启动$digest脏循环并将其传播到子作用域中​ 1.7 $digest会等待$evalAsync队列清空和$watch不再变化，此时才将整个修改后的DOM交给浏览器开始重新渲染显示。二、对脏检查与$apply的细节描述​ 2.1 页面进行双向绑定时，scope作用域会自动为其增加watcher函数监听值的变化，并自动调用$scope.$apply()。​ 2.2 何时开始监听值的变化呢？这就是脏检查的产生原因。调用$scope.$digest()开始进入脏循环，会触发一系列watcher函数，一旦发生值的变化，就调用回调函数。​ 2.3 angular会在上下文作用域中自动调用$apply进入脏循环，我们也可以手动调用$scope.$digest进入脏检测，或者调用$scope.$apply()方法，后者实际调用$rootScope.$digest()。​ 2.4 何时需要手动调用进入脏检测呢？angular只负责将其上下文变更做出自动响应，但是如果我们在上下文之外（例如：JS代码修改、setTimeout等），就需要手动调用。三、代码爬坑3.1 ng-app启动Angular应用1var app = angular.module('myApp',[]);[ ]:方括号表示该模块是否需要依赖某些模块。无论有无依赖，这个数组参数必须存在。3.2 自定义指令细节​ 以代码为例：12345678910111213141516171819app.directive('myDirective',function($templateCache)&#123; return &#123; restrict:'EACM', //分别代表元素、属性、类名、注释 template:'', //可直接编写模板HTML代码，还可使用$templateCache.get('')获取外部文件 scope:&#123; XX:'=', //实现父子域双向绑定，直接将子域该内容绑定到父域 XX:'@', //将子域中&#123;&#123;&#125;&#125;中的值单向绑定到父域，父域改变是子域会改变，但反之不行 XX:'&amp;', //将子域XX函数处理以及返回值绑定到父域函数执行 &#125;, controller:function($scope,$element)&#123;&#125;, //注意三者参数名 link:function(scope,el,attr)&#123;&#125;, compile:function(tElement,tAttrs,transclude)&#123; //此处参数可省略 return &#123; pre:function(scope,iElement,iAttrs)&#123;&#125;, post:function(scope,iElement,iAttrs)&#123;&#125; &#125; &#125; &#125;&#125;);link、controller、compile三者关系controller先运行。如果link和compile都存在只运行compile（实际上link就是compile中的postLink函数）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>angularJs</tag>
      </tags>
  </entry>
</search>
