<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[也谈angular细节爬坑]]></title>
    <url>%2F2017%2F08%2F15%2F%E4%B9%9F%E8%B0%88angular%E7%BB%86%E8%8A%82%E7%88%AC%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一、angular实现原理略谈​ 虽然业界将angular规划为MVC模式，但是它更有MVVM影子，其双向绑定就实现了ViewModel。下面聊聊我对angular实现原理的理解：​ 1.1 浏览器加载HTML页面时，遇到外联&lt;script&gt;标签时会发出HTTP请求来下载该外部文件​ 1.2 angular.js如此被下载下来，并监听页面DomContentLoad事件​ 1.3 一旦DomContentLoad事件触发（即页面DOM加载完成）时，angular就开始执行​ 1.4 angular会在页面中寻找ng-app字样标签，一旦找到则开始angular启动初始化（如果没有找到，angualr期望我们手动启动应用，需要使用angular的bootstrap()方法，即：12var ele = document.createElement('div');Angular.bootstrap(ele,['myApp']);1Angular.bootstrap(document,['myApp']);注意：bootstrap()方法只能启动angular应用一次）。​ 1.5 angular会在找到ng-app后 将其值配置injector服务。一旦程序加载完成，injector服务会配置compile服务，该服务的作用是遍历页面找到所有的指令将它们的链接函数合并为一个单一的链接函数，并将链接函数编译好的模板托付给$rootScope。​ 1.6 $rootScope将在angular上下文中启动$digest脏循环并将其传播到子作用域中​ 1.7 $digest会等待$evalAsync队列清空和$watch不再变化，此时才将整个修改后的DOM交给浏览器开始重新渲染显示。二、对脏检查与$apply的细节描述​ 2.1 页面进行双向绑定时，scope作用域会自动为其增加watcher函数监听值的变化，并自动调用$scope.$apply()。​ 2.2 何时开始监听值的变化呢？这就是脏检查的产生原因。调用$scope.$digest()开始进入脏循环，会触发一系列watcher函数，一旦发生值的变化，就调用回调函数。​ 2.3 angular会在上下文作用域中自动调用$apply进入脏循环，我们也可以手动调用$scope.$digest进入脏检测，或者调用$scope.$apply()方法，后者实际调用$rootScope.$digest()。​ 2.4 何时需要手动调用进入脏检测呢？angular只负责将其上下文变更做出自动响应，但是如果我们在上下文之外（例如：JS代码修改、setTimeout等），就需要手动调用。三、代码爬坑3.1 ng-app启动Angular应用1var app = angular.module('myApp',[]);[ ]:方括号表示该模块是否需要依赖某些模块。无论有无依赖，这个数组参数必须存在。3.2 自定义指令细节​ 以代码为例：12345678910111213141516171819app.directive('myDirective',function($templateCache)&#123; return &#123; restrict:'EACM', //分别代表元素、属性、类名、注释 template:'', //可直接编写模板HTML代码，还可使用$templateCache.get('')获取外部文件 scope:&#123; XX:'=', //实现父子域双向绑定，直接将子域该内容绑定到父域 XX:'@', //将子域中&#123;&#123;&#125;&#125;中的值单向绑定到父域，父域改变是子域会改变，但反之不行 XX:'&amp;', //将子域XX函数处理以及返回值绑定到父域函数执行 &#125;, controller:function($scope,$element)&#123;&#125;, //注意三者参数名 link:function(scope,el,attr)&#123;&#125;, compile:function(tElement,tAttrs,transclude)&#123; //此处参数可省略 return &#123; pre:function(scope,iElement,iAttrs)&#123;&#125;, post:function(scope,iElement,iAttrs)&#123;&#125; &#125; &#125; &#125;&#125;);link、controller、compile三者关系controller先运行。如果link和compile都存在只运行compile（实际上link就是compile中的postLink函数）]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>指令，爬坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular爬坑日记1：angularJS自定义指令中controller、link、compile区别]]></title>
    <url>%2F2017%2F08%2F15%2Fangular%E7%88%AC%E5%9D%91%E6%97%A5%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[​ 之所以要说到这三者关系，是之前被人问到这个自定义指令中compile与link的区别，当时只是记得一点点区别，说完就觉得我可能之前学了个假的自定义指令。所以在此系统性的做一下这方面的笔记，加深印象。​ 废话不多说，开始吧！一、angularJS指令加载​ 在讲三者关系之前，势必是要说一说angular是如何加载指令到运行这一系列流程的。查看angular源码，可以看到这样一句话：123&gt; *Since angular looks for this directive when it is loaded (doesn&apos;t wait for the&gt; DOMContentLoaded event), it must be placed on an element that comes before the script which loads angular。&gt;​ 大致的意思应该是(本人英语水平不咋滴)：在页面访问包含angularJS的&lt;script&gt;标签并加载完成时，angular引擎就开始遍历DOM节点查找angular指令了]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>指令，爬坑</tag>
      </tags>
  </entry>
</search>
